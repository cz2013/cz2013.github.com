[{"title":"Weex iOS 模块开发&环境搭建","date":"2018-05-06T16:00:00.000Z","path":"2018/05/07/weexToIOS/","text":"学习weex的ios开发，虽然weex官方有一些文档，但是变化很大维护的不是很及时，而且不算很细致，对于一个iOS还没探索过的前端同学，多走了很多坑。所以，我把走过的路总结下，希望对后面的同学能起到帮助。 目的目的是能快速开发调试ios端weexmodule的和component。所以没有现有的App，一切从零开始，一切减法为上。 环境搭建iOS开发环境 和 CocoaPods搭建iOS开发环境，下载Xcode。这里会要求注册开发者，只要普通免费的苹果账号（无需付费成为开发者）就可以申请iOS证书打包安装到自己手机测试。 此处有坑就是新的Xcode要求mac升级到10.13.4版本。 CocoaPods是用gem命令安装，需要设置ruby软件源。参考CocoaPods安装方法-2018.03.27 新建App打开Xcode，新建Single View App，输入相关信息，create。 第一次开发的同学可能需要在signing中配置下team信息为自己。这个时候的App就可以运行试试了。 点击运行（三角形图标），发现只是build success的提示，模拟器呢？此一坑，设置下即可解决。 选择Product - Scheme - Edit Scheme： 在Run中配置如下图。 再运行Xcode，模拟器就打开了。 注意，这里可以选择运行的模拟器，如果连上自己的苹果手机，还能在模拟器选择中选择识别的手机型号，从而构建匹配自己手机的APP。 集成Weex首先要在App中引入Weex SDK，进入App的代码根目录。运行如下命令： 12//初始化生成Podfilepod init 查询WeexSDK，会出现很多条信息，找到WeexSDK的，复制下面的pod &#39;WeexSDK&#39;, &#39;~&gt; 0.18.0&#39;修改Podfile。1pod search WeexSDK 修改Podfile：1vim Podfile 在# use_frameworks!后添加查询的值pod &#39;WeexSDK&#39;, &#39;~&gt; 0.18.0&#39;，保存退出。 下载WeexSDK依赖：1pod install --no-repo-update 现在Weex已经集成到我们的App中了。再用Xcode打开App，可以在Linked Frameworks and Libraries中发现添加了libPods。 1open iosTest.xcworkspace 开发Module以前面的App为例，用Xcode打开的工程里找到iosTest文件夹，可以在其中新建我们自定义的module的h和m文件。 iosTest文件夹上右键 - New File，新建h（Header File），取名MyMd5Module - create 修改内容如下：123456#import &lt;Foundation/Foundation.h&gt;#import &lt;WeexSDK/WeexSDK.h&gt;@interface MyMd5Module : NSObject&lt;WXModuleProtocol&gt;@end 新建同名的.m文件。内容如下：123456789101112131415161718192021222324252627282930313233343536#import &quot;MyMd5Module.h&quot;#import &lt;CommonCrypto/CommonDigest.h&gt;static NSString *encryptionKey = @&quot;momo(Nd′568GGS%d~~9naei&apos;;45vhhafdjkv]32rpks;lg,];:vjo(&amp;**&amp;^)&quot;;@implementation MyMd5ModuleWX_EXPORT_METHOD(@selector(toMd5:callback:))- (NSString *)toMd5:(NSString *)string callback:(WXModuleKeepAliveCallback)callback&#123; if (!string) &#123; if (callback) &#123; callback(@&quot;Error: message should be passed correctly.&quot;,NO); &#125; return nil; &#125; const char *cStr = [string UTF8String]; unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(cStr, (CC_LONG)strlen(cStr), digest); NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [result appendFormat:@&quot;%02X&quot;, digest[i]]; &#125; NSLog(@&quot;%@&quot;, result); if (callback) &#123; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;,@&quot;data&quot;:result&#125;, NO); &#125; return nil;&#125;@end 踩坑如下：1、所以Weex注册方法应该设置为-开头，表示是实例方法。+表示是类方法。weex中注册方法都会实例化方法，所以之前用了+，总是在模拟器端看不到效果。2、weexpack工具官方的一些说明和weex官方页面的说明有区别，暴露module对外方法是在.m文件内定义的。但是module的注册方法是在App的AppDelegate.m中定义的。按照官方说明的代码可以实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#import &quot;AppDelegate.h&quot;#import &quot;WXAppConfiguration.h&quot;#import &quot;WXSDKEngine.h&quot;#import &quot;WXLog.h&quot;#import &quot;MyMd5Module.h&quot;@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //business configuration [WXAppConfiguration setAppGroup:@&quot;myApp&quot;]; [WXAppConfiguration setAppName:@&quot;WeexDemo&quot;]; [WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;]; //init sdk environment [WXSDKEngine initSDKEnvironment]; //register custom module and component，optional //[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]]; [WXSDKEngine registerModule:@&quot;mwsMd5&quot; withClass:[MyMd5Module class]]; //[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)]; //set the log level [WXLog setLogLevel: WXLogLevelAll]; return YES;&#125;- (void)applicationWillResignActive:(UIApplication *)application &#123; // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state. // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.&#125;- (void)applicationDidEnterBackground:(UIApplication *)application &#123; // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.&#125;- (void)applicationWillEnterForeground:(UIApplication *)application &#123; // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.&#125;- (void)applicationDidBecomeActive:(UIApplication *)application &#123; // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.&#125;- (void)applicationWillTerminate:(UIApplication *)application &#123; // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.&#125;@end 模拟器调试我们知道App运行Weex页面其实是打开了一个url。所以我们还需要在App中开发默认打开页面进入我们的bundle.js页面。 App的界面代码在ViewController.m中，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ViewController.h&quot;#import &lt;WeexSDK/WXSDKInstance.h&gt;@interface ViewController ()//WXSDKInstance属性@property (nonatomic, strong) WXSDKInstance *instance;//URL属性(用于指定加载js的URL,一般声明在接口中,我们为了测试方法写在了类扩展中.)@property (nonatomic, strong) NSURL *url;//Weex视图@property (weak, nonatomic) UIView *weexView;@end@implementation ViewController//重写viewDidLoad- (void)viewDidLoad&#123; [super viewDidLoad]; // 创建WXSDKInstance对象 _instance = [[WXSDKInstance alloc] init]; // 设置weexInstance所在的控制器 _instance.viewController = self; //设置weexInstance的frame _instance.frame = self.view.frame; //设置weexInstance用于渲染的`js`的URL路径(后面说明) [_instance renderWithURL:self.url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil]; //为了避免循环引用声明一个弱指针的`self` __weak typeof(self) weakSelf = self; //设置weexInstance创建完毕回调 _instance.onCreate = ^(UIView *view) &#123; weakSelf.weexView = view; [weakSelf.weexView removeFromSuperview]; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; // 设置`weexInstance`出错的回调 _instance.onFailed = ^(NSError *error) &#123; //process failure NSLog(@&quot;处理失败:%@&quot;,error); &#125;; //设置渲染完成的回调 _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish NSLog(@&quot;渲染完成&quot;); &#125;;&#125;- (NSURL *)url &#123; if (!_url) &#123; _url = [[NSBundle mainBundle] URLForResource:@&quot;examples/native/index&quot; withExtension:@&quot;js&quot;]; &#125; return _url;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;- (void)dealloc&#123; // 销毁WXSDKInstance实例 [self.instance destroyInstance];&#125;@end 代码里可以看到，URLForResource我设置为examples/native/index.js。你也可以设置为其他值。vue的工程一般在其他文件夹，也有热更新。所以只要在Xcode中更目录下右键 - Add Files to “xxx”中选择vue的工程目录即可。或者直接把热更新编译后的js引入也行。记得修改这里的路径。 最后点击运行，看到结果了~","tags":[]},{"title":"Vue源码分析（二）","date":"2018-04-08T16:00:00.000Z","path":"2018/04/09/vue2/","text":"在Vue源码分析一中，我们分析了Vue的构造函数初始化。现在我们针对细节进行分析，了解Vue的实际运行方案。首先最基础的，就是生命周期。 init上一章中提过instance模块包含了Vue构造函数的实例方法、生命周期管理和事件等。instacnce模块的index.js代码也有简单分析。vue实例化后除了为Vue的prototype挂载一系列属性方法，还运行了方法：this._init(options)。该方法在init.js文件的initMixin函数中定义。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ // a flag to avoid this being observed vm._isVue = true // 合并options属性:如果传入的option是一个组件，执行initInternalComponent, 否则执行mergeOptions; if (options &amp;&amp; options._isComponent) &#123; // 内部使用Vnode部分使用 // 以Vue.options为原型创建vm.$options, 并把options中的属性复制到vm.$options; initInternalComponent(vm, options) &#125; else &#123; // mergeOptions函数的参数：[parent, child, vm]，实现options的合并功能，不同于Object.assign的简单合并，它还对数据还进行了一系列的操作： // 1、格式化props、injects和directives // 2、递归调用mergeOptions, 并把mixins的内容递归处理到parent对象中 // 3、mergeField所有的parent和child属性。 // key值为生命周期或者watch时，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的钩子将在组件自身钩子之前调用. // 当为prosp/methods/inject/computed/components/directives/filters时，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; // expose real self vm._self = vm //生命周期方法初始化 initLifecycle(vm) initEvents(vm) initRender(vm) // 调用生命周期钩子的方法，此时是beforeCreate阶段 callHook(vm, &apos;beforeCreate&apos;) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props // 生命周期进入created阶段 callHook(vm, &apos;created&apos;) // 如果有el属性，将内容挂载到el中去。 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 可以看到，在_init(options)方法调用后，会运行options的处理方法，然后就是初始化生命周期、事件、render等等。生命周期方法的源码可见lifecycle.js文件，还有一个非常值得关注的就是callHook函数。不过callHook和initLifecycle两个方法都是在lifecycle.js文件中的。所以下面看lifecycle.js。 lifecycle首先上图，这是官方提供的Vue生命周期流程图： beforeCreate 和 created beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 前面init模块代码里看到，在实例化vue时，callHook了beforeCreate和created，的确如上图的流程所示。最后判断vm.$options.el是否存在，存在则调用vm.$mount(vm.$options.el)方法。 vm.$mount() 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。 如果没有提供 elementOrSelector参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。 这个方法返回实例自身，因而可以链式调用其它实例方法。 vm.$mount()方法不是core文件夹内的代码，你会发现在plateforms模块和entry-runtime-with-compiler模块中能找到它： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//entry-runtime-with-compiler中的vm.$mount()方法：//保存platforms模块的$mountconst mount = Vue.prototype.$mount//重写覆盖$mount方法Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; //query内部判断了一下el是不是字符串，不是的话就直接返回，所以我们的el也可以直接传入dom元素。 el = el &amp;&amp; query(el) if (el === document.body || el === document.documentElement) &#123; return this &#125; const options = this.$options // 判断是否有render函数，如果有就不做处理直接执行mount.call(this, el, hydrating)。如果没有render函数，则获取template，template可以是#id、模板字符串、dom元素，如果没有template，则获取el以及其子内容作为模板。 if (!options.render) &#123; // 获取template let template = options.template if (template) &#123; if (typeof template === &apos;string&apos;) &#123; if (template.charAt(0) === &apos;#&apos;) &#123; template = idToTemplate(template) &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; // 编译template，对我们最后生成的模板进行解析，生成render if (template) &#123; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns &#125; &#125; // 执行 $mount 方法 return mount.call(this, el, hydrating)&#125; 然后我们看mount.call(this, el, hydrating)方法代码： 12345678// src/platforms/web/runtime/index.jsVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 该方法使用了lifecycle中的mountComponent方法： 123456789101112131415161718192021222324252627282930export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode &#125; callHook(vm, &apos;beforeMount&apos;) let updateComponent updateComponent = () =&gt; &#123; //render函数返回的是一个VNode对象(虚拟dom对象) vm._update(vm._render(), hydrating) &#125; new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */) hydrating = false if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &apos;mounted&apos;) &#125; return vm&#125; 现在callHook(vm, ‘beforeMount’)和callHook(vm, ‘mounted’)都出现了~ beforeMount 和 mounted beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。 mounted：el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 由代码可知，在callHook(vm, ‘beforeMount’)后，定义了updateComponent函数，对vm实例做了watcher的观察者绑定。然后就是设置_isMounted为true，并告诉mounted了。什么？这个中间不是应该进行mount相关操作吗？？？这里非常关键的方法就是 _update() 和 Watcher了。 _update()在生命周期的update阶段会被用到。我们先看Watcher方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm vm._watchers.push(this) if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; ... this.expression = process.env.NODE_ENV !== &apos;production&apos; ? expOrFn.toString() : &apos;&apos; if (typeof expOrFn === &apos;function&apos;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` + &apos;Watcher only accepts simple dot-delimited paths. &apos; + &apos;For full control, use a function instead.&apos;, vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; get () &#123; pushTarget(this) let value const vm = this.vm if (this.user) &#123; try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; &#125; else &#123; value = this.getter.call(vm, vm) &#125; if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() return value &#125; 可见updateComponent函数被当做expOrFn参数传入Watcher中后，被value = this.getter.call(vm, vm)触发了。所以，触发了vm._update(vm._render(), hydrating)方法。这里完成beforeMount和mounted中间的渲染过程。但是官方所说的create vm.$el and replace el with it不符合，vm.$el = el方法是在beforeMount前执行的。 beforeUpdate 和 updated beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 上面提到的vm._update(vm._render(), hydrating)方法中，vm._render()会根据数据生成一个vdom, vm.update()则会对比新的vdom和当前vdom，并把差异的部分渲染到真正的dom树上， 在vm.render()执行过程中，这个watcher会作为依赖被添加到vm的data中去，如果data发生变化，就会通知这个watcher重新执行vm._update(vm._render(), hydrating)。所以，beforeUpdate和updated需要在_update方法中查看： 123456789101112131415161718192021222324252627282930313233343536373839// 在lifecycle文件的lifecycleMixin模块内部提供了Vue.prototype._update、Vue.prototype.$forceUpdate和Vue.prototype.$destroy方法Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this if (vm._isMounted) &#123; callHook(vm, &apos;beforeUpdate&apos;) &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) vm.$options._parentElm = vm.$options._refElm = null &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; &#125; 执行callHook(vm, ‘beforeUpdate’)后在vm.__patch__方法中实现组件的update方法：包括真实dom的创建、虚拟dom的diff修改、dom的销毁等。这个在这章不讨论。那updated在哪里被触发呢？在scheduler 的 callUpdateHooks 方法，该方法遍历了 watcher 数组。 1234567891011// src/core/observer/scheduler.jsfunction callUpdatedHooks (queue) &#123; let i = queue.length while (i--) &#123; const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123; callHook(vm, &apos;updated&apos;) &#125; &#125;&#125; 这个 callUpdatedHooks 在 flushSchedulerQueue 方法中调用。 123456789101112131415161718192021222324/** * 刷新队列并运行watcher */function flushSchedulerQueue () &#123; flushing = true let watcher, id queue.sort((a, b) =&gt; a.id - b.id) for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] id = watcher.id has[id] = null watcher.run() &#125; const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // 调用组件的updated和activated生命周期 callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue)&#125; 继续找下去 1234567891011export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true // 此参数用于判断watcher的ID是否存在 …… if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125;&#125; 最终在 watcher.js 找到 update 方法： 123456789101112// src/core/observer/watcher.jsupdate () &#123; // lazy 懒加载 // sync 组件数据双向改变 if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) // 排队watcher &#125;&#125; 等于是队列执行完 Watcher 数组的 update 方法后调用了 updated 钩子函数。 beforeDestroy 和 destroyed beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 前面说到在lifecycle文件的lifecycleMixin模块内部提供了Vue.prototype._update、Vue.prototype.$forceUpdate和Vue.prototype.$destroy方法。下面看destroy方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &apos;beforeDestroy&apos;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &apos;destroyed&apos;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125; 这是一个销毁 Vue 实例的过程，将各种配置清空和移除。beforeDestroy和destroyed的钩子都在这里被触发。 好了，现在按照Vue官网的流程图走了一遍生命周期，希望对大家有用~","tags":[]},{"title":"Vue源码分析（一）","date":"2018-04-07T16:00:00.000Z","path":"2018/04/08/vue-1/","text":"由于项目需求，最近需要学习vue和weex相关。所以先研究下vue的源码。 结构分析研究的vue版本号是2.5.16。核心文件下的目录结构如下： components：组件模块； global-api：接口模块； instance：初始化模块； observer：观察者模块； util：工具模块； vdom：虚拟树模块； index.js：入口文件 入口分析入口文件先看入口文件index.js源码，内容不多，做了下面几件事。 export的是instance里的index； 另外，还运行了global-api中的index文件暴露的initGlobalAPI接口； 使用Object.defineProperty对Vue绑定了$isServer、$ssrContext和FunctionalRenderContext的方法属性。这几个方法都是针对vue的服务端渲染的方法。这里的defineProperty方法也是vue浏览器兼容性支持限制的一个原因； 定义了Vue.version，初始化为’__VERSION__‘。1234567891011121314151617181920212223242526import Vue from &apos;./instance/index&apos;import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;import &#123; isServerRendering &#125; from &apos;core/util/env&apos;import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123; value: FunctionalRenderContext&#125;)Vue.version = &apos;__VERSION__&apos;export default Vue instance模块所以要研究Vue，instance是关键的研究入口。打开instance文件夹的index.js文件，内容如下： 定义Vue构造函数，在函数中调用this._init(options)，该方法在init.js中的initMixin方法中定义。 调用方法：initMixin(Vue)、stateMixin(Vue)、eventsMixin(Vue)、lifecycleMixin(Vue)和renderMixin(Vue)。这些方法的作用就是在Vue的原型 prototype 上挂载一系列方法或属性。1234567891011121314151617181920212223import &#123; initMixin &#125; from &apos;./init&apos;import &#123; stateMixin &#125; from &apos;./state&apos;import &#123; renderMixin &#125; from &apos;./render&apos;import &#123; eventsMixin &#125; from &apos;./events&apos;import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;import &#123; warn &#125; from &apos;../util/index&apos;function Vue (options) &#123; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 这篇文章先对整体结构进行分析，所以不详细研究instance模块的内部代码了。不过我们可以看到，初始化Vue后的函数结构如下：1234567891011121314151617181920212223242526272829303132333435363738// initMixin(Vue) src/core/instance/init.js **************************************************Vue.prototype._init = function (options?: Object) &#123;&#125;// stateMixin(Vue) src/core/instance/state.js **************************************************Vue.prototype.$dataVue.prototype.$set = setVue.prototype.$delete = delVue.prototype.$watch = function()&#123;&#125;// renderMixin(Vue) src/core/instance/render.js **************************************************Vue.prototype.$nextTick = function (fn: Function) &#123;&#125;Vue.prototype._render = function (): VNode &#123;&#125;Vue.prototype._s = _toStringVue.prototype._v = createTextVNodeVue.prototype._n = toNumberVue.prototype._e = createEmptyVNodeVue.prototype._q = looseEqualVue.prototype._i = looseIndexOfVue.prototype._m = function()&#123;&#125;Vue.prototype._o = function()&#123;&#125;Vue.prototype._f = function resolveFilter (id) &#123;&#125;Vue.prototype._l = function()&#123;&#125;Vue.prototype._t = function()&#123;&#125;Vue.prototype._b = function()&#123;&#125;Vue.prototype._k = function()&#123;&#125;// eventsMixin(Vue) src/core/instance/events.js **************************************************Vue.prototype.$on = function (event: string, fn: Function): Component &#123;&#125;Vue.prototype.$once = function (event: string, fn: Function): Component &#123;&#125;Vue.prototype.$off = function (event?: string, fn?: Function): Component &#123;&#125;Vue.prototype.$emit = function (event: string): Component &#123;&#125;// lifecycleMixin(Vue) src/core/instance/lifecycle.js **************************************************Vue.prototype._mount = function()&#123;&#125;Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;&#125;Vue.prototype._updateFromParent = function()&#123;&#125;Vue.prototype.$forceUpdate = function () &#123;&#125;Vue.prototype.$destroy = function () &#123;&#125; initGlobalAPI从入口文件可知，在引入instance文件的Vue模块后，调用了initGlobalAPI(Vue)方法。该方法代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* @flow */import config from &apos;../config&apos;import &#123; initUse &#125; from &apos;./use&apos;import &#123; initMixin &#125; from &apos;./mixin&apos;import &#123; initExtend &#125; from &apos;./extend&apos;import &#123; initAssetRegisters &#125; from &apos;./assets&apos;import &#123; set, del &#125; from &apos;../observer/index&apos;import &#123; ASSET_TYPES &#125; from &apos;shared/constants&apos;import builtInComponents from &apos;../components/index&apos;import &#123; warn, extend, nextTick, mergeOptions, defineReactive&#125; from &apos;../util/index&apos;export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== &apos;production&apos;) &#123; configDef.set = () =&gt; &#123; warn( &apos;Do not replace the Vue.config object, set individual fields instead.&apos; ) &#125; &#125; Object.defineProperty(Vue, &apos;config&apos;, configDef) // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &apos;s&apos;] = Object.create(null) &#125;) // this is used to identify the &quot;base&quot; constructor to extend all plain-object // components with in Weex&apos;s multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125; 由代码可知，调用了initGlobalAPI为Vue生成了新的属性方法：1234567891011121314151617181920Vue.configVue.util = utilVue.set = setVue.delete = delVue.nextTick = util.nextTickVue.options = &#123; components: &#123; KeepAlive &#125;, directives: &#123;&#125;, filters: &#123;&#125;, _base: Vue&#125;Vue.useVue.mixinVue.cid = 0Vue.extendVue.component = function()&#123;&#125;Vue.directive = function()&#123;&#125;Vue.filter = function()&#123;&#125; 其他继续看core的代码： 设置Vue的实例属性$isServer和$ssrContext。服务器端渲染端属性。 设置Vue类属性 FunctionalRenderContext。也是为了ssr服务器端渲染提供的属性。 设置Vue类的版本号","tags":[]},{"title":"postcss简介","date":"2018-03-31T16:00:00.000Z","path":"2018/04/01/postcss-study/","text":"postcss官网定义，postcss是一个将css转化成js的工具。A tool for transforming CSS with JavaScriptpostcss是一个css构建工具。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。我们常常在webpack中使用它，但是它可以在例如gulp的其他地方使用，感兴趣的同学可以自己研究。在github上有详细的介绍。这里我结合我们的mk系统架构简单介绍下常用的postcss api。 常用API介绍autoprefixer虽然在simple-momo项目中木有使用这个api，我还是忍不住要介绍它，因为太常用了。 autoprefixer的作用是识别css中的新属性，并为其自动生成添加浏览器兼容前缀的代码，从而保证尽量少的codding就可以实现兼容性。例如，代码中这么写： 123::placeholder &#123; color: gray;&#125; 使用autoprefixer构建后就变成这样：123456789101112::-webkit-input-placeholder &#123; color: gray;&#125;:-ms-input-placeholder &#123; color: gray;&#125;::-ms-input-placeholder &#123; color: gray;&#125;::placeholder &#123; color: gray;&#125; postcss-smart-import可以看到第一个引入的api插件就是它。postcss-smart-import在github上star数并不高，why？因为： This project is not maintained anymore. Please use postcss-import instead 好吧，可以考虑更新包了～～ 不过不影响我们了解它。 PostCSS plugin for loading/including other files (transform @import rules by inlining content) and quering/referring assets (referred in url() functions). 翻译过来就是：postcss是一个加载引入其他文件（将@import方法引入的css转成内联）和查询静态资源（css中url（）方法中指定的静态资源）的插件。 顾名思义，它主要解决的css的引入问题。独特的@import规则，css内静态资源的引入问题…… ps：该插件的作者推荐它作为postcss众多插件中首先引入的： This plugin should probably be used as the first plugin of your list. This way, other plugins will work on the AST as if there were only a single file to process, and will probably work as you can expect. postcss-cssnextpostcss-cssnext插件帮助我们能使用css最新特性，和js的polifill一样一样的。同理，它也帮助我们解决这些新特性的浏览器兼容性问题了。上官网描述： -PostCSS-cssnext is a PostCSS plugin that helps you to use the latest CSS syntax today. It transforms CSS specs into more compatible CSS so you don’t need to wait for browser support.- 还可以看cssnext官网。下面再介绍下配置项。 browsers：允许开发者定义需要兼容的浏览器范围。默认值： browserslist default &gt; 1%, last 2 versions, Firefox ESR, Opera 12.1 features：顾名思义，定义属性。官方推荐使用browsers代替这个属性。 warnForDuplicates：重复引入报警，默认true。官方认为除非确认要关闭该功能，否则不要更改。举个例子，引入autoprefixer + cssnext，引入autoprefixer里已经引入了cssnext，所以就可以起作用了。 warnForDeprecations：冲突时报警。官方声明这里不要改，除非你做好承担后果的准备（赤果果的威胁～） precssprecss提供了一个插件包,提供类似sass的语法特性。功能包括变量、条件语句和迭代器等等，感兴趣等同学继续挖吧～ postcss-px-to-viewportpostcss-px-to-viewport字面意思就是将px转成viewport等单位（vw, vh, vmin, vmax）。手机端开发经常需要用到这个。 同样可以在代码中看到这个是有配置项的。我们再一起了解下这些配置项的作用。首先看默认属性值： 123456789&#123; viewportWidth: 320, viewportHeight: 568, unitPrecision: 5, viewportUnit: &apos;vw&apos;, selectorBlackList: [], minPixelValue: 1, mediaQuery: false&#125; viewportWidth：(Number类型) viewport的宽度 viewportHeight：(Number类型) viewport的高度 unitPrecision：(Number类型) 我理解是允许的小数点最大位数. viewportUnit：(String类型) 设置要转成的单位 selectorBlackList：(Array类型) 设置忽略转换单位的选择器。Array的值可以是字符串、正则等。 webpack引入方式以webpack3语法为例，一般引入方式如下：首先在moudle模块引入postcss加载器，放在style-loader和css-loader后面：12345678910111213141516//这些选项确定如何处理项目中不同类型的模块。 module: &#123; rules: [ // CSS 和 POSTCSS 加载器，使用嵌入 CSS. &#123; //设置对应的资源后缀. test: /\\.(css|scss)$/, //设置后缀对应的加载器. use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader?modules&apos; &#125;, &#123; loader: &apos;postcss-loader&apos; &#125;, ] &#125; ] &#125; 然后，我们上面介绍的各种api配置放在哪里呢？答案是根目录下的postcss.config.js文件里，配置格式如下（非源码）：12345678910111213141516module.exports = &#123; plugins: [ require(&apos;postcss-conditionals&apos;)(), require(&apos;postcss-simple-vars&apos;)(), require(&apos;postcss-each&apos;)(), require(&apos;postcss-for&apos;)(), require(&apos;postcss-mixins&apos;)(), require(&apos;postcss-import&apos;)(), require(&apos;postcss-nested&apos;)(), require(&apos;postcss-atroot&apos;)(), require(&apos;cssnext&apos;)(&#123; features: &#123;rem: false&#125; &#125;), require(&apos;postcss-extend&apos;)() ]&#125; postcss-loader的配置文件就是postcss.config.js。它有个很有意思的规则，就是对于postcss-loader来说，他优先取同目录下的postcss.config.js的配置属性。也就是我们可以根据业务情况在多个含有css文件的目录内配置不同的postcss.config.js，解析css时优先读取离他最近的postcss.config.js。为复杂场景的css构建方案提供了更加灵活的方式。 后话看到vue-cli已经引入了postcss-loader，查看package.json，果然没有引入。不过第三方开发的postcss插件还是需要引入的～","tags":[{"name":"前端技术","slug":"前端技术","permalink":"http://cz2013.github.io/tags/前端技术/"}]},{"title":"react 受控组件和非受控组件","date":"2017-09-27T16:00:00.000Z","path":"2017/09/28/react-control-uncontrol/","text":"什么是受控组件和非受控组件首先举个栗子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;//受控组件class ControlInput extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;&apos; &#125;; &#125; changeHandler(e)&#123; this.setState(&#123;value: e.target.value&#125;); &#125; submit()&#123; alert(this.state.value); &#125; render() &#123; return (&lt;div&gt; &lt;h3&gt;受控组件：&lt;/h3&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;(e)=&gt;this.changeHandler(e)&#125;/&gt; &lt;button onClick=&#123;()=&gt;this.submit()&#125; &gt;提交&lt;/button&gt; &lt;/div&gt;) &#125;&#125;//非受控组件class UnControlInput extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; submit()&#123; alert(this.myInput.value); &#125; render() &#123; return (&lt;div&gt; &lt;h3&gt;非受控组件：&lt;/h3&gt; &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.myInput = input&#125; /&gt; &lt;button onClick=&#123;()=&gt;this.submit()&#125; &gt;提交&lt;/button&gt; &lt;/div&gt;) &#125;&#125;class Index extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return (&lt;div&gt; &lt;ControlInput /&gt; &lt;UnControlInput /&gt; &lt;/div&gt;) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById(&apos;app&apos;)); 这两个组件的功能和表现是一模一样的，但是根据其对表单值的控制行为，我们将其区分为受控组件和非受控组件两种。下面是官网对受控组件和非受控组件的介绍和定义：We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”. In most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself. 受控组件：也被称做“受限组件”或“受约束组件”。其所有状态属性的更改都由React 来控制，即它根据组件的props和state来改变组件的UI表现形式。非受控组件：不受React 的状态控制（state或props）。（非受控组件是在底层实现时内部维护了自己的状态state，这样表现出用户输入任何值都能反应到元素上。）交互流程图如下： 两种组件比较React 认为：组件应当只受状态的改变而改变，虽然使用受控组件在代码量上有所增加，但推荐使用受控组件。受控组件的组件状态由React 控制，可以更好的控制数据流，在用户输入时能够更新组件状态。 受控组件的优势：1、更符合React组件状态控制UI的思想。2、外部props可以实时控制组件state，进而同步UI数据。3、可以非常容易实现对用户输入的验证，或者对用户交互做额外的处理。 通过onChange方法来实现监控控制。当然，非受控组件也可以使用onChange，但是如果使用的话就不如直接做成受控组件了，代码量的优势也没有了 那非受控组件真的就没有什么意义了吗？当然不是。对无需外部控制且无复杂交互的表单往往可以使用非受控组件。例如antd的Tree组件，当有非常多的节点时,对TreeNode进行控制就不是很明智。Tree组件本身可以实现结果的保存获取，而再使用受控的方式则必须在每次变化时转换为输出格式，在控制变量变化时再转换为内部计算格式。如果转换过程比较耗时就会感到卡顿。（非受控组件内部可能由很多受控组件组成，受控组件和非受控组件组合实现React界面，两者缺一不可） 受控组件和非受控组件的属性对比如下： 对比内容 受控组件 非受控组件 value/checked 设置 不设置 onChange 可使用 可使用 defaultValue/defaultChecked 不起作用 可使用 ref 没有必要 可使用 其他 可使用 可使用 受控组件用法整理1、根据上面思路，整理受控组件数据流控制流程图如下： 2、多表单元素可共享事件处理器在创建表单组件时，有时多个组件的事件处理器功能相同或相似，这时我们可以在多个组件间共享一个事件处理器，而不用分别编写事件处理器。共享事件处理器时，需要解决参数传递的问题。 a. 传参：事件监控函数传参区别组件，这里注意需要绑定this。（常用）b. 通过底层DOMname属性区分：12345handleChange: function(event) &#123; var newState = &#123;&#125;; newState[event.target.name] = event.target.value; this.setState(newState);&#125; c. 通过React addon的LinkedStateMixin方法实现共享(已经被React v15.5.抛弃，请转上面) ANTD Form组件项目中常会用到ANTD的FORM组件来实现复杂表单。Input等Data Entry表单元素组合出现在FormItem中，共同组成了Form表单。然而我们发现，我们往往并没有使用state或者props控制单个表单元素的value，而是使用了ANTD Form组件提供的getFieldDecorator方法注册监听各个表单元素。ANTD提供了一套API来控制表单元素，使用的是非受控的组件方法。 从ANTD Form组件官方示例和API介绍可以知道，ANTD Form组件实现了对表单元素的实时校验、获取设置值、UI扩展等功能。下面一段话摘自官网： 经过 getFieldDecorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果：1、你不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。2、你不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 里的 initialValue。3、你不应该用 setState，可以使用 this.props.form.setFieldsValue 来动态改变表单值。 举个简单的例子：1234567891011121314//此处省略......&lt;Form&gt; &lt;FormItem &#123;...formItemLayout&#125; label=&apos;标识字体&apos; &gt;&#123;getFieldDecorator(&apos;prmtff&apos;, &#123; rules: [&#123;required: true, pattern:/^[A-Za-z \\-,]*$/, message: &apos;请填写标识字体&apos;&#125;], initialValue: value &#125;)( &lt;Input /&gt; )&#125; &lt;/FormItem&gt;&lt;/Form&gt;//此处省略...... 看下源码：123456789101112131415161718192021222324252627282930313233343536//name即上面的prmtff，唯一标示，fieldOption即一系列配置项getFieldDecorator: function getFieldDecorator(name, fieldOption) &#123; var _this2 = this; //getFieldProps内实现了一系列配置绑定，根据传参生成返回一个inputProps对象 var props = this.getFieldProps(name, fieldOption); //返回的方法传参fieldElem即示例中的&lt;Input /&gt; return function (fieldElem) &#123; /*getFieldMeta(name)方法在createFieldsStore.js中 *&#123; * key: &apos;getFieldMeta&apos;, * value: function getFieldMeta(name) &#123; * if (!this.fieldsMeta[name]) &#123; * this.fieldsMeta[name] = &#123;&#125;; * &#125; * return this.fieldsMeta[name]; * &#125; *&#125; *保证一个name只存储一个field */ var fieldMeta = _this2.fieldsStore.getFieldMeta(name); var originalProps = fieldElem.props; //此处省略非production代码 //...... fieldMeta.originalProps = originalProps; //内部实现了ref来控制表单元素，非受控组件用法 fieldMeta.ref = fieldElem.ref; /* React.cloneElement * 参数：TYPE（ReactElement），[PROPS（object）]，[CHILDREN（ReactElement）] * 克隆并返回一个新的 ReactElement （内部子元素也会跟着克隆），新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props（只要在第二个参数中有定义）。 */ return _react2[&apos;default&apos;].cloneElement(fieldElem, (0, _extends3[&apos;default&apos;])(&#123;&#125;, props, _this2.fieldsStore.getFieldValuePropValue(fieldMeta))); &#125;;&#125;, 由源码可以看出，ANTD Form表单的确是用的非受控方式实现了对表单元素的控制，当然由于函数方法封装覆盖了表单元素的属性，所以ANTD官方也不建议在使用Form组件时使用value和defaultValue来直接控制表单元素（你可能会发现即使设置了也会失效，因为从源码可以看出，对表单元素属性进行了覆盖合并）。 受控组件和非受控组件在react的使用中非常普遍，互相嵌套。Form表单如何更高效的使用，欢迎后续继续研究讨论。","tags":[]},{"title":"如何发布一个react组件包到NPM上","date":"2017-08-15T16:00:00.000Z","path":"2017/08/16/how-publish-react-npm/","text":"近期由于项目需要，开发了一个react版本的Panel抽屉组件。该组件使用react和es6实现，引入了外部的react组件、css文件和png图片。在本地项目中开发调试通过后，面临将该组件构建发布的问题。我们知道使用npm publish命令可实现发布，但在发布前我们还有一些步骤需要完成。 1、文件结构|-assets |-index.css |-panel-close.png|-lib |-index.js|-src |-index.jsx|-node_modules|-.babelrc|-.gitignore|-.npmignore|-index.js|-README.md|-package.json|-webpack.config.js 2、src - index.jsx核心代码在src的index.jsx中，assets中是引入的css和图片。index.jsx部分代码如下，使用es6，引入了react、react-dom、react-addons-css-transition-group和一个css文件。12345678910111213/* * ...... */import React, &#123;Component&#125; from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;import ReactCSSTransitionGroup from &apos;react-addons-css-transition-group&apos;;import &apos;../assets/index.css&apos;;//......class Panel extends Component &#123;//......&#125;module.exports = Panel; 3、lib - index.js为了能被其他人使用，需要对index.jsx进行es5处理，react处理，css和图片的处理。构建过后生成的js文件存放在lib文件夹中，即index.js。这个是实际被项目使用的文件。 4、index.js根目录下的index.js是什么呢？在这里引入lib内的index.js，在package.json中设置main的值就是这个index.js。内容如下：1module.exports = require(&apos;./lib/index.js&apos;); 5、package.json内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;name&quot;: &quot;@bizfe/biz-rc-panel&quot;, &quot;description&quot;: &quot;React UI Plugin&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;, &quot;dev&quot;: &quot;rimraf lib &amp;&amp; babel src --watch --copy-files --source-maps --extensions .es6,.es,.jsx --out-dir lib&quot;, &quot;compile&quot;: &quot;rimraf lib &amp;&amp; babel src --copy-files --source-maps --extensions .es6,.es,.jsx --out-dir lib&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;main&quot;: &quot;index.js&quot;, &quot;style&quot;: &quot;assets/index.css&quot;, &quot;keywords&quot;: [ &quot;react&quot;, &quot;react-component&quot;, &quot;react-panel&quot;, &quot;panel&quot; ], &quot;maintainers&quot;: [ &#123; &quot;name&quot;: &quot;chenzhen&quot;, &quot;email&quot;: &quot;chenzhen202130@sogou-inc.com&quot; &#125; ], &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;&quot; &#125;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;^15.0.0&quot;, &quot;react-dom&quot;: &quot;^15.0.0&quot;, &quot;react-addons-css-transition-group&quot;: &quot;15.6.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.4.5&quot;, &quot;babel-loader&quot;: &quot;^6.2.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.3.13&quot;, &quot;babel-preset-react&quot;: &quot;^6.3.13&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.3.13&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;rimraf&quot;: &quot;^2.5.0&quot;, &quot;style-loader&quot;: &quot;^0.13.0&quot;, &quot;file-loader&quot;: &quot;0.9.0&quot;, &quot;url-loader&quot;: &quot;0.5.7&quot;, &quot;webpack&quot;: &quot;1.12.9&quot;, &quot;webpack-dev-server&quot;: &quot;1.14.0&quot; &#125;&#125; dependencies内是组件本身需要引入的插件，在index.jsx中有引用。devDependencies里的则是构建需要引入的插件。babel相关的几个是用来处理es6和react的，css-loader是处理css文件中的url()，style-loader 引入css文件的插件，file-loader主要用来处理图片，url-loader是对file-loader的上层封装，比如webpack中对图片的加载器配置，然后加webpack……main是入口文件，这里引入的是根目录下的index.jsstyle是css的入口文件，引入的是assets/index.cssscripts中写入 “build”: “webpack”方法，用于后面构建组件命令 6、webpack.config.js内容如下：123456789101112131415161718192021222324252627var path = require(&apos;path&apos;);module.exports = &#123; entry: path.resolve(__dirname, &apos;./src/index.jsx&apos;), output: &#123; path: path.resolve(__dirname, &apos;./lib&apos;), library: &apos;Panel&apos;, libraryTarget: &apos;umd&apos;, filename: &apos;index.js&apos; &#125;, externals: &#123; &apos;react&apos; : &apos;umd react&apos;, &apos;react-dom&apos; : &apos;umd react-dom&apos; &#125;, module: &#123; loaders: [&#123; test:/\\.(jpe?g|png|gif|woff|woff2|eot|ttf|svg)([\\?]?.*)$/, loader: &apos;url?limit=10000&amp;name=image/[name].[md5:hash:hex:7].[ext]&apos; &#125;, &#123; test: /\\.css$/, // Only .css files loader: &apos;style!css&apos; // Run both loaders &#125;,&#123; test: /\\.jsx$/, loader: &apos;babel&apos; &#125;] &#125;&#125; 由上面代码可知，构建的是src/index.jsx，输入到lib文件夹下index.js文件。需要增加library，内容是组件的类名，这里是Panel。libraryTarget写 ‘umd’。这种配置方法，告诉webpack，输出的时候会采用umd模块化方案。配合externals的内容，能将外部依赖的内容（react和react-dom）不打包编译进lib内的index.js中。这种配置在插件的构建中是十分常见的。在我的这个组件构建中，使用后代码行数是原来的十分之一。module中则对图片、css和jsx做了相关的构建。 7、其他相关除了上面的文件，还有一些文件需要我们填写。README.md：需要我们编辑好，引导使用者更好的使用。.babelrc：用来设置babel转码的规则和插件的基本的格式，内容如下：123&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;, &quot;stage-0&quot;]&#125; .gitignore:用于配置git不需要加入版本管理的文件.npmignore:.用于配置npm不需要加入版本管理的文件，这里我们需要增加不需要提交到npm上的文件。node_modules：这个是编译自动下载的插件存放处，该文件夹应该写入.gitignore和.npmignore中 8、构建写完所有内容，使用npm install命令下载引用。然后使用npm run build调用webpack打包编译组件生成lib文件夹和里面的内容。该命令写在了package.json里。如果都木有问题了，使用npm publish命令发布私有包。完成。","tags":[]},{"title":"JSX引起的一些思考","date":"2017-08-02T16:00:00.000Z","path":"2017/08/03/JSX/","text":"问题： 为什么使用JSX声明组件时，最外层的组件根元素只允许使用单一根元素。？ className而不是class，htmlFor而不是for？ 自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头？ 为什么注释是{/*……..*/}而不是或者/*……..*/？ JSX是什么It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript. JSX 其实就是 JavaScript 的一种扩展语法。JSX 的官方定义是类 XML 语法的 ECMAscript 扩展，完美地利用了 JavaScript 自带的语法和特性，并使用大家熟悉的 HTML 语法来创建虚拟元素。Babel 将JSX编译成 React.createElement() 调用。下面是一个简单的jsx例子：1&lt;div id=&quot;main&quot;&gt;&lt;/div&gt; 12345678910function getName(name) &#123; return &lt;span style=&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;&#123;name&#125;&lt;/span&gt;&#125;const ele = ( &lt;h1&gt; Hello! &#123;getName(&apos;SOGOU FE&apos;)&#125; &lt;/h1&gt;);ReactDOM.render(ele, document.getElementById(&quot;main&quot;)); 被Babel编译成：123456789101112131415161718&quot;use strict&quot;;function getName(name) &#123; return React.createElement( &quot;span&quot;, &#123; style: &#123; color: &quot;red&quot; &#125; &#125;, name );&#125;var ele = React.createElement( &quot;h1&quot;, null, &quot;Hello! &quot;, getName(&apos;SOGOU FE&apos;));ReactDOM.render(ele, document.getElementById(&quot;main&quot;)); 解释1：为什么使用JSX声明组件时，最外层的组件根元素只允许使用单一根元素？因为 JSX 语法会被转化为 React.createElement(component,props,…children) 调用，而该函数的第一个参数只允许传入单元素，而不允许传入多元素。 解释2：className而不是class，htmlFor而不是for？因为class和for都是javascript关键字，所以 React.js 中定义了一种新的方式：className和htmlFor。 解释3：JSX标签的第一个部分指定了React元素的类型，首字母大写的标签说明了它是一个引用的React组件，这些标签会被编译称为一个命名属性的直接引用，所以如果需要使用JSX标签，那么Foo必须要在作用域内被定义。 解释4：为什么注释是{/……../}而不是或者/……../？JSX内部的注释只是 JS 表达式。你只需要在一个标签的子节点内(非最外层)小心地用 {} 包围要注释的部分。最外层的注释可以用// so: React DOM 使用驼峰(camelCase)属性命名约定； 默认情况下，在渲染之前，React DOM 会格式化(escapes) JSX中的所有值，所有的数据都被转义成字符串处理，以避免 XSS(跨站脚本) 攻击。 …… React.createElement()解析在官网createElement()是这样定义的：12345React.createElement( type, [props], [...children]) 创建并返回一个新的给定类型的 React 元素 。这个 type(类型) 参数可以是一个标签名字字符串（例如 ‘div’ 或’span’），或者是一个 React 组件类型（类或者是函数）。 官网上建议使用 JSX 来描述你的 UI 应该是什么样。每个 JSX 元素都是调用 React.createElement() 的语法糖。 如果使用 JSX ，你不必显示地调用该方法。 上源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Create and return a new ReactElement of the given type. * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement */ReactElement.createElement = function (type, config, children) &#123; var propName; // Reserved names are extracted // 初始化参数 var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; // 从config中提取出保留属性：ref、key、self和source // 另外，self and source are DEV only properties. if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = &apos;&apos; + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object // 提取出config中除了保留属性外的prop，放入props变量中 // hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。 // RESERVED_PROPS = &#123; key: true, ref: true, __self: true, __source: true&#125;; for (propName in config) &#123; if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // Children can be more than one argument, and those are transferred onto // the newly allocated props object. // 处理children，挂到props的children属性下 var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (&quot;development&quot; !== &apos;production&apos;) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // Resolve default props // 取出组件类中的静态变量defaultProps，并给未在JSX中设置值的属性设置默认值 if (type &amp;&amp; type.defaultProps) &#123; var defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; //只在开发调试阶段调用，属于开发阶段错误提示的相关代码，可忽略 //webpack打包判断执行环境是不是生产环境，如果是生产环境会压缩并且没有提示警告之类的东西 if (&quot;development&quot; !== &apos;production&apos;) &#123; if (key || ref) &#123; if (typeof props.$$typeof === &apos;undefined&apos; || props.$$typeof !== REACT_ELEMENT_TYPE) &#123; var displayName = typeof type === &apos;function&apos; ? type.displayName || type.name || &apos;Unknown&apos; : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; &#125; // 返回一个ReactElement对象 return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125;; ReactElement源码：1234567891011121314151617181920var ReactElement = function (type, key, ref, self, source, owner, props) &#123; var element = &#123; // This tag allow us to uniquely identify this as a React Element //这个是React元素的唯一标示，作用：没有加这个$$typeof之前，object被认为是有效的React Element。为了将React Element和普通的对象区分开,判断React的children是否是一个React Element, 来尽可能防止xss漏洞。 $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner &#125;; //此处省略非生产环境代码 return element;&#125;; JSX是如何在React中生效的前面说了，如果使用 JSX，你不必显示地调用该方法。那是因为在mountComponent()方法中会进行组件渲染，调用instantiateReactComponent()方法。instantiateReactComponent方法会根据node传参的不同类型，创建不同的组件对象。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Given a ReactNode, create an instance that will actually be mounted. * * @param &#123;ReactNode&#125; node * @return &#123;object&#125; A new instance of the element&apos;s constructor. * @protected */// 初始化react组件，node是一个ReactElement对象，是节点元素在React中的表示，new Component(xxx).render()function instantiateReactComponent(node) &#123; var instance; if (node === null || node === false) &#123; // 空对象 instance = new ReactEmptyComponent(instantiateReactComponent); &#125; else if (typeof node === &apos;object&apos;) &#123; var element = node; //抛出错误的校验，要求node的type为function或者string型 !(element &amp;&amp; (typeof element.type === &apos;function&apos; || typeof element.type === &apos;string&apos;)) ? &quot;development&quot; !== &apos;production&apos; ? invariant(false, &apos;Element type is invalid: expected a string (for built-in components) &apos; + &apos;or a class/function (for composite components) but got: %s.%s&apos;, element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined; // Special case string values if (typeof element.type === &apos;string&apos;) &#123; // type为string则表示DOM原生对象，比如div span等 instance = ReactNativeComponent.createInternalComponent(element); &#125; else if (isInternalComponentType(element.type)) &#123; // This is temporarily available for custom components that are not string // representations. I.e. ART. Once those are updated to use the string // representation, we can drop this code path. // 保留给以后版本使用，此处暂时不会涉及到 instance = new element.type(element); &#125; else &#123; // React自定义组件 instance = new ReactCompositeComponentWrapper(); &#125; &#125; else if (typeof node === &apos;string&apos; || typeof node === &apos;number&apos;) &#123; // 元素是一个string时，对应的比如&lt;span&gt;123&lt;/span&gt; 中的123 // 本质上它不是一个ReactElement，但为了统一，也按照同样流程处理，称为ReactDOMTextComponent instance = ReactNativeComponent.createInstanceForText(node); &#125; else &#123; !false ? &quot;development&quot; !== &apos;production&apos; ? invariant(false, &apos;Encountered invalid React node of type %s&apos;, typeof node) : invariant(false) : undefined; &#125; if (&quot;development&quot; !== &apos;production&apos;) &#123; &quot;development&quot; !== &apos;production&apos; ? warning(typeof instance.construct === &apos;function&apos; &amp;&amp; typeof instance.mountComponent === &apos;function&apos; &amp;&amp; typeof instance.receiveComponent === &apos;function&apos; &amp;&amp; typeof instance.unmountComponent === &apos;function&apos;, &apos;Only React Components can be mounted.&apos;) : undefined; &#125; // Sets up the instance. This can probably just move into the constructor now. instance.construct(node); // These two fields are used by the DOM and ART diffing algorithms // respectively. Instead of using expandos on components, we should be // storing the state needed by the diffing algorithms elsewhere. // 初始化参数，这两个参数是DOM diff时用到的 instance._mountIndex = 0; instance._mountImage = null; if (&quot;development&quot; !== &apos;production&apos;) &#123; instance._isOwnerNecessary = false; instance._warnedAboutRefsInRender = false; &#125; // Internal instances should fully constructed at this point, so they should // not get any new fields added to them at this point. if (&quot;development&quot; !== &apos;production&apos;) &#123; if (Object.preventExtensions) &#123; Object.preventExtensions(instance); &#125; &#125; return instance;&#125;module.exports = instantiateReactComponent; 从instantiateReactComponent源码中可见，针对不同的node，有以下几种方法： new ReactEmptyComponent(instantiateReactComponent)：node为null ReactNativeComponent.createInternalComponent(element)：node是对象且node.type为string（原生dom对象）。调用ReactDOMComponent(tag)生成。做了安全性校验（防止注入）、大小写转换等等，详见源码。 new ReactCompositeComponentWrapper()：node是对象且type为function（React自定义组件）。详情见ReactCompositeComponentMixin方法。提供的mountComponent方法实现了对React子组件的不断递归。 ReactNativeComponent.createInstanceForText(node)：node是字符串或者数字（文字 or 数字）。详情见方法ReactDOMTextComponent 下面是React.render时触发的jsx流程图： 当state变化或者props变化时，dom是如何重新渲染的呢？前面知道了，不同的元素类型已经实例化了相应的组件了。每个组件里除了有mountComponent外，还有一个receiveComponent方法。他来实现组件的重新渲染。下面是流程图： 源码看到这里，你可能会想到react的diff算法。diff算法入口就是ReactDOMComponent里的_updateDOMChildren方法。这个不难理解，所有的React组件分解到最后都是dom的处理（或者字符串数字的简单处理）。所以diff算法在_updateDOMChildren，用来处理虚拟dom树的更新。具体算法这里就不做分析了~ 事件监听在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听。React.js 帮我们封装好了一系列的 on 的属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 on 就可以了。而且你不需要考虑不同浏览器兼容性的问题，React.js 都帮我们封装好这些细节了。 没有经过特殊处理的话，这些 on* 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上。也就是说， 这样的写法不会有什么效果的。 下面看源码，首先查找ReactDOMComponent下mountComponent方法，发现针对不同的tag类型，React提供了相应的dom组件，并调用mountWrapper方法。随便选择一个，例如select，ReactDOMSelect.mountWrapper(this, props, context);看这个mountWrapper方法：123456789101112131415161718192021222324 mountWrapper: function (inst, props) &#123; if (&quot;development&quot; !== &apos;production&apos;) &#123; checkSelectPropTypes(inst, props); &#125; var value = LinkedValueUtils.getValue(props); inst._wrapperState = &#123; pendingUpdate: false, initialValue: value != null ? value : props.defaultValue, onChange: _handleChange.bind(inst), wasMultiple: Boolean(props.multiple) &#125;; &#125;,//这里省略若干function _handleChange(event) &#123; var props = this._currentElement.props; var returnValue = LinkedValueUtils.executeOnChange(props, event); this._wrapperState.pendingUpdate = true; ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this); return returnValue;&#125; 它提供了onChange的属性接口，并通过_handleChange方法定义。同理，其他的dom组件都有mountWrapper方法，并定义了一些接口方法。所以，我们在写react时需要按照接口规范些onClick或者onChange等方法。并且我们可以看到React组件对象ReactCompositeComponent的mountComponent方法内就没有这种方法的接口定义，所以， 这样的写法不会有什么效果的。当然，你可以试试自定义接口写…… 事件中的 this我们在React开发中离不开this的使用，常常会遇到一些问题。所以最后再简单讨论下JSX中的this使用。this具体是由其上下文决定的。也就是说，一个Component组件里面的this，是在它被实例化后，才被确定下来，指向这个实例。（我们在ReactCompositeComponent的mountComponent方法内就能找到new Component方法）。但是在JSX中我们经常遇到困惑，例如，在render里写子组件，并且传递方法。这个方法里调用的this到底指向哪个呢？还是要看它的上下文。如下面的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;class TodoApp extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); this.state = &#123;items: [], text: &apos;&apos;&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;TODO&lt;/h3&gt; &lt;TodoList items=&#123;this.state.items&#125; removeFunc=&#123;(i)=&gt;this.removeFunc(i)&#125; removeAll=&#123;this.removeAll.bind(this)&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;&#123;&apos;Add #&apos; + (this.state.items.length + 1)&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; removeFunc(i)&#123; let items = this.state.items; items.splice(i, 1); this.setState(&#123;items&#125;) &#125; removeAll()&#123; this.setState(&#123;items:[]&#125;); &#125; handleChange(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125; handleSubmit(e) &#123; e.preventDefault(); var newItem = &#123; text: this.state.text, id: Date.now() &#125;; this.setState((prevState) =&gt; (&#123; items: prevState.items.concat(newItem), text: &apos;&apos; &#125;)); &#125;&#125;class TodoList extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul&gt; &#123;this.props.items.map((item,index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125; &lt;button onClick=&#123;()=&gt;this.props.removeFunc(index)&#125;&gt;删除&lt;/button&gt;&lt;/li&gt; ))&#125; &lt;/ul&gt; &#123;this.props.items.length?&lt;button onClick=&#123;this.props.removeAll&#125;&gt;全部删除&lt;/button&gt;:null&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;TodoApp /&gt;, document.getElementById(&quot;main&quot;)); 子组件TodoList中onClick方法调用了this.props.removeFunc方法，即调用父组件传入的removeFunc方法。但是是由子组件调用的，所以一般情况下（未绑定this时），removeFunc方法上下文的this是子组件TodoList。这里我们在父组件传递removeFunc时将this做了绑定，确定指向父组件，才能操作items参数，达到删除的作用。es6的箭头函数，直接使用.bind(this)都可以达到绑定this到其定义的上下文中的作用。我们也可以看看源码里事件监听的处理方式：12345678910111213141516171819202122232425262728293031323334mountComponent: function (rootID, transaction, context) &#123; ...... switch (this._tag) &#123; ...... case &apos;input&apos;: ReactDOMInput.mountWrapper(this, props, context); props = ReactDOMInput.getNativeProps(this, props, context); break; ...... &#125; ...... //参数useCreateElement决定创建dom节点的时候是使用document.createElement方法，还是拼接字符串 if (transaction.useCreateElement) &#123; ...... this._updateDOMProperties(&#123;&#125;, props, transaction, el); this._createInitialChildren(transaction, props, context, el); mountImage = el; &#125; else &#123; ...... &#125;&#125;//省略_updateDOMProperties: function (lastProps, nextProps, transaction, node) &#123; //省略DOMPropertyOperations.setValueForProperty(node, propKey, nextProp); //省略&#125;//省略setValueForProperty: function (node, name, value) &#123; //省略 node.setAttribute(attributeName, &apos;&apos; + value); //省略&#125;, 可见React没有对this绑定进行特殊处理，开发者自己根据需要定制绑定即可。","tags":[]},{"title":"wordpress本地替换themes主题","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/wp-themes/","text":"因为虚机不联网，所以搭建完wordpress后在仪表盘无法下载主题。选择下载主题zip文件后，可以上传主题 出现提示：无法建立目录wp-content/uploads/2017/05。有没有上级目录的写权限？ 解决方法：1、查看/opt/lampp/htdocs/wp-content文件夹下有无uploads和upgrade文件夹，没有，新建，设置权限为 777或755；1sudo chmod 777 uploads/ 2、查看发现wp_options表中upload键值为空。此时需要修改wp_options表中upload键 值如下图。 3、重启服务，重新操作上传主题12sudo /opt/lampp/lampp stop/opt/lampp/lampp start 这个问题就解决了。但是在安装成功后有报错 1Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 64 bytes) in /opt/lampp/htdocs/wp-includes/class-wp-hook.php on line 298 解决方案：在/opt/lampp/etc内的php.ini修改memory_limit=4096M，然后重启","tags":[]},{"title":"在XAMPP环境搭建WordPress网站","date":"2017-05-02T16:00:00.000Z","path":"2017/05/03/xampp-wp/","text":"前面介绍了XAMPP的环境安装，这里介绍在XAMPP环境搭建WordPress网站。 WordPress放入XMAPPXAMPP安装后的默认地址是：/opt/lampp。进入/opt/lampp/htdocs内，删除所有文件，把WordPress下载解压后的文件放入其中。 因为之前已经配置好XAMPP，重新在浏览器中输入ip地址，回车。会发现如下界面： 创建数据库1、外网访问解决方案：点击现在就开始会发现需要填写数据库名称。所以在开始配置WordPress前我们先创建数据库注意，因为是在虚机上配置，不能通过输入http:/xx.xxx.xxx.xx/phpmyadmin/来进入数据库，会有下面报错：（访问所请求的对象只能从本地网络获得。） 这个问题官网(https://www.apachefriends.org/faq_linux.html)有指出：How do I enable access to phpMyAdmin from the outside? 1、编辑当前路径（XAMPP根目录）下的etc/extra/httpd-xampp.conf2、在此文件中，找到下面的行，删除“phpmyadmin”，保存。1&lt;LocationMatch \"^/(?i:(?:xampp|security|licenses|phpmyadmin|webalizer|server-status|server-info))\"&gt; 3、重启Apache 然而我这里没有这行代码，官网上的解决方案没有更新到最新版本的方案。于是自己来找答案吧~~找到如下代码： 123456# since XAMPP 1.4.3&lt;Directory \"/opt/lampp/phpmyadmin\"&gt; AllowOverride AuthConfig Limit Require local ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 修改成如下： 12345678# since XAMPP 1.4.3&lt;Directory \"/opt/lampp/phpmyadmin\"&gt; AllowOverride AuthConfig Limit Require all granted Order allow,deny Allow from all ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 停止XAMPP 1sudo /opt/lampp/lampp stop 启动XAMPP 1/opt/lampp/lampp start 这个时候访问http:/xx.xxx.xxx.xx/phpmyadmin就成功了 2、设置密码默认安装的xampp是没有设置任何密码的，运行命令： 1/opt/lampp/lampp security 按照提示设置密码，控制访问安全性。这一步可以不做。 3、数据库配置：个人不熟悉后端数据库语言，使用phpmyadmin图形界面工具是很方便的。下面就介绍怎么为Wordpress博客网站创建管理数据。 首先，进入phpmyadmin页面。这个远程访问问题前面已经解决了，如果设置密码的话需要输入用户名密码，MySQL/phpMyAdmin部分设置的密码，用户名默认是pma。登录后界面上面已有。 点击数据库，新建数据库。输入数据库名称，选择“utf8_general_ci”的编码： 然后数据库创建成功，里面无数据。 继续创建WordPress继续填写创建WordPress： 提交后： 按照步骤要求修改wp-config.php然后点击进行安装 填写完后点击安装WordPress WordPress数据库错误： [Got error ‘this version of PCRE is compiled without UTF support at offset 0’ from regexp]DELETE FROM wp_options WHERE optionname REGEXP ‘^rss[0-9a-f]{32}(_ts)?$’这里Wordpress已经安装成功了。报错的是数据库PCRE的问题。PCRE 是perl所用到的正则表达式，目的是让所装的软件支持正则表达式。默认情况下，Nginx只处理静态的网页请求，也就是html.如果是来自动态的网页请求，比如.php，那么Nginx就要根据正则表达式查询路径，然后把.PHP交给PHP去处理。输入命令：1pcretest -C 可知，该版本pcre不支持utf-8。这里下载最新的PCRE到linux安装即可。 下载最新的PCRE解压缩放入linux文件夹内，cd到该文件夹根目录安装。安装前需要查看是否已安装旧的PCRE，有的话要删除后才能安装。运行命令：1rpm -qa pcre 发现有安装过。在删除系统自带的PCRE之前，要先备份一下libpcre.so.0这个文件，因为RPM包的关联性太强，在删除后没libpcre.so.0这个文件时我们装PCRE是装不上的。运行命令备份：1cp /lib64/libpcre.so.0/ 如果没备份就卸载，那新版本安装时会报错： 这就很麻烦啦，要么安装要么复制过来。安装的话要考虑linux类型下载，可能还会有一系列其他的报错，这里我从其他服务器copy了一份。64位的，放到lib64里。怕怕~~ 卸载旧的PCRE，运行命令1rpm -e --nodeps pcre 运行命令（选择8.40版本） 12345cd pcre-8.40chmod +x configure #为了解决./configure: Permission denied、./configuremakesudo make install 安装成功，检查： 1pcretest -C 配置configure 1./configure --prefix=/opt/lampp --enable-utf8 --enable-unicode-properties 注意，改完配置要重新make12345makemake installsudo cp .libs/* /opt/lampp/libsudo /opt/lampp/lampp restart 然后可以看配置是否成功了：1sudo /opt/lampp/bin/pcretest -C 这个时候怎么看有木有解决问题呢？之前报错页面是http://xxxxxx/wp-admin/setup-config.php?step=2&amp;language=zh_CN但是输入进去发现 删除该文件重新配置一遍吧~~注意，数据库数据也删掉。按照步骤最后没出现这个错误。泪流满面： 点击登录，出现wordpress仪表盘页面：","tags":[]},{"title":"hexo deploy无法生成贡献值的解决方案","date":"2017-05-01T16:00:00.000Z","path":"2017/05/02/hexo-deploy/","text":"博客改成用hexo后写了一段时间，发现github上contributions竟然没有生成。小绿点去哪里了呢？经过我反复调研最后终于解决了问题，并且原来没生成的部分也恢复到正确的贡献值了。 官方解释从官网上可以得知，翻译如下： Issues 和 pull requests： 这个操作是在一年之内这个操作是针对一个独立的仓库，不能是fork Commits：当你的commits满足以下条件时，它才会被展示出来： 1、一年之内提交的commits2、commits使用的email地址是与你的Github账号相关联的3、这些commits是在一个独立的仓库而不是fork仓库4、这些commits是在：在默认分支上（通常是master）在gh-pages分支(包含 Project Pages sites 的仓库) 此外，至少满足下面条件中的一个（主要针对你Commit的仓库不是你创建的）： 1、你是这个仓库的协作者，或者是这个版本库的拥有组织中的一员2、你fork过这个仓库3、你对这个仓库发起过pull request或者issue4、你对这个仓库标记了Star 注意：私有库的贡献仅仅对私有库成员显示 问题解决我的情况是，自己拉的hexo私人博客，master默认分支。按照上面的条件过滤下来，应该是第2点“commits使用的email地址是与你的Github账号相关联的”可能有问题。 尝试1：输入命令：12git config --global user.name \"用户名\"git config --global user.email \"邮箱地址\" 结果：失败 尝试2：修改.deploy_git.git中的config的内容，在最后增加：123[user] name = 用户名 email = 邮箱地址 结果：失败 排查解决为什么呢？用户名邮箱应该都配置了呀？于是，找到了正确的排查方法： 1、进入github中博客所在界面 2、点击红框处进入最近的commit信息3、在浏览器url地址后面加上.patch，回车进入下面界面，就能看到最新的提交信息了： 对比一看，用户名和邮箱是正确的。也就是说之前的尝试1和2都是成功的。那问题就是这个用户名和邮箱到底对不对呢？用户名和邮箱从下面红框处可以看到：但是，邮箱并不是这里的邮箱，而是下面的：我发现自己的这两个邮箱不一样……自己作的结果……于是，最后的解决方案是：将这个Email改成了之前设置的一致的邮箱。激活后发现贡献值恢复正确了。","tags":[]},{"title":"LAMP环境搭建","date":"2017-04-26T16:00:00.000Z","path":"2017/04/27/LAMP1/","text":"要搭建一个前端技术博客，经过调研决定使用 Wordpress + LAMP 的web框架。这里先介绍下LAMP环境搭建。 LAMP（Linux + Apache + Mysql/MariaDB + Perl/PHP/Python），一组常用来搭建动态网站或者服务器的开源软件，本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。从网站的流量上来说，70%以上的访问流量是LAMP来提供的，LAMP是最强大的网站解决方案。（——摘自百度百科） 这里我们使用的是 Linux + Apache + Mysql + PHP 方案。经过调研，分别安装很麻烦，只需要装一个XAMPP即可。 XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、Linux、Solaris、Mac OS X 等多种操作系统下安装使用，支持多语言：英文、简体中文、繁体中文、韩文、俄文、日文等。XAMPP 是一个易于安装且包含 MySQL、PHP 和 Perl 的 Apache 发行版。XAMPP 的确非常容易安装和使用：只需下载，解压缩，启动即可。（——摘自百度百科） 下载首先，下载XAMPP。选择安装环境对应的版本，这里我选择XAMPP for Linux v5.6.30 (PHP 5.6.30)。使用winSCP将软件发送到待部署的linux虚机上。但是安装双击就卡死了，这个需要用linux命令来安装。 通过SecureCRT登录虚机，cd到安装包路径，运行：12chmod 755 xampp-linux-*-installer.run 这句话的意思是开通安装权限。chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行2.与文件所有者同属一个用户组的其他用户可读可执行3.其它用户组可读可执行 安装然后再安装，运行：12sudo ./xampp-linux-*-installer.run 按照提示一步步下来，默认安装到 /opt/lampp 。 这样就成功了。进入到/opt/lampp就能看到目录结构如下： 启动输入命令： 1/opt/lampp/lampp start 启动web服务器，从图中可以看到apache、mysql、ftp服务都启动OK了 另外请注意，你可以使用图形化工具轻松管理您的服务器。使用以下命令启动此工具： 12cd /opt/lamppsudo ./manager-linux.run (or manager-linux-x64.run) 在浏览器上输入服务器地址访问http:xx.xxx.xxx.xx发现报错nginx 404原来虚机里配置过nginx，且nginx使用端口80，xampp中apache也是80端口。据调研xampp目录下有一个shell脚本，在这个脚本里面，把80端口写死了。所以修改nginx端口号为8081。在/usr/local/nginx/conf中修改nginx.conf——server——listen 为8081 为了方便，不用每次命令都输入一串地址，配置命令如下： 1sudo ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx 然后可直接通过nginx命令停止 1pkill -9 nginx 查看，master进程没有了 1ps -ef | grep nginx 启动nginx： 1nginx 停止xampp 1sudo /opt/lampp/lampp stop 然后重新启动 1/opt/lampp/lampp start 现在在浏览器上输入服务器地址访问http:xx.xxx.xxx.xx就ok了","tags":[]},{"title":"WebVR最佳实践探索","date":"2017-04-19T16:00:00.000Z","path":"2017/04/20/webVr-best-try/","text":"前段时间研究了一下webVR，对使用a-frame开发webVR做了一个简要介绍和入门级的实例分享（《WebVR之A-Frame开发分享》）。这个分享是针对现有的a-frame API和对外的示例Demo开发的，但是在实际的开发过程中，遇到了很多新的需求和API Demo上都介绍不明确的地方。加上a-frame中文文档的缺失，现有相关中文分享也比较匮乏，在后面对外系统的webVR页面开发时遇到了很多问题，这里想和大家一起分享。也为a-frame和webVr的开发做点自己的微末贡献。 题目叫webVr最佳实践探索，不见得是最佳实践，所以加上探索二字。如果有更好的方法欢迎大家给予建议。 引入a-frame js文件发现官网上提供的js文件，demo引入的js文件五花八门。而且a-frame官网提供的js版本更新快，api文档也在经常更新。那到底引入哪个js文件呢？他们之间的区别在哪里？ 下面整理了下遇到的几款js： aframe-vx.x.x.min.js：可通过https://aframe.io/releases/x.x.x/来引用，x.x.x表示最新稳定版本号，推荐使用。项目中我是下载放入本地引用的最新版aframe-v0.5.0.min.js。aframe-master.min.js：master版本不稳定的包含新功能的a-frame版本，我的开发中一度用的是这个版本。尝鲜用~aframe-animation-component.min.js：aframe-xxx-component.min.js是aframe的一些模块扩展js，例如常用的动画效果模块js。实际中未用到，但是可以参照下面网址：https://github.com/ngokevin/kframe/tree/master/components/animationaframe-extras.xxx.min.js：A-Frame VR的附加组件和助手。常用到aframe-extras.loaders.min.js，来加载3d模型文件obj等。具体可参考网址：https://github.com/donmccurdy/aframe-extras 这里不讨论min和非min，大家都知道，是否压缩处理的区别 AFRAME.registerComponent的引入位置按照一般的开发逻辑思维，会将对元素的事件监听绑定行为放在底部，在dom元素加载完进行绑定。但是在实际开发中遇到了问题。我的写法是这样： 1234567891011121314151617&lt;html&gt;&lt;head&gt;......&lt;script src=\"/src/aframe-v0.5.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a-scene&gt;......&lt;/a-scene&gt;&lt;script type=\"text/javascript\"&gt;......AFRAME.registerComponent('cursor-listener', &#123; ......&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行后发现部分cursor-listener元素并没有绑定事件成功。后来研究发现，script引入的位置放在前面能避免这个问题。 1234567891011121314151617&lt;html&gt;&lt;head&gt;......&lt;script src=\"/src/aframe-v0.5.0.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;......AFRAME.registerComponent('cursor-listener', &#123; ......&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a-scene&gt;......&lt;/a-scene&gt;&lt;/body&gt;&lt;/html&gt; 我理解是a-frame是对内元素进行了语法解析，最后生成的canvas插入dom元素中。把事件监听绑定放在前面，按照从前往后解析的顺序，才会在解析时同时进行事件绑定。而放在后面的话，canvas生成正在进行中，事件绑定出现遗漏。 中文字体在展示文字的过程中，发现不支持中文直接作为的value值直接展示。现有的aframe文字demo也全部用的英文。怎么解决？问吧：http://stackoverflow.com/questions/42688290/aframehow-show-chinese-characters-in-aframe 直接上解决方法： 通过sdf font的方式，用herio制作中文字体，注意，只能制作成一张png，否则报错。具体步骤如下： 1、下载Hiero：nightlies/runnables/runnable-hiero.jar2、运行herio：在hiero下载文件夹路径下运行java -jar runnable-hiero.jar3、编辑字体：可以看到Hiero里有下面一些操作项。在1中选择字体，如微软雅黑；选择渲染方式java；在3中添加需要用该字体展现的所有文字和符号，记住，遗漏的话这个字最后也无法展现在页面上哦；4里面是效果选择，双击内容会在5处生成相关项；在6处编辑字体的边距等格式；在7处注意保证pages是1，即最后只生成一张.png；最后在8处保存生成字体。 https://github.com/libgdx/libgdx/wiki/Distance-field-fonts 4、调用字体：字体生成后就是调用了，在中添加字体类，后面直接调用： 12345678&lt;a-assets&gt;......&lt;a-mixin id=\"text\" text=\"align: left;width: 20; wrapCount:40;color: white;font: /asset/font/yahei.fnt;\" &gt;&lt;/a-mixin&gt;......&lt;/a-assets&gt;......&lt;a-text mixin=\"text\" text=\"wrap-count:60;value: 测试\"&gt;&lt;/a-text&gt;...... 加载优化当这个demo里充斥了大量的图片时，加载优化就变得十分需要了。 1、图片处理：图片需要处理成web格式。这个大家都知道就不说了。2、异步请求：在demo里有很多事件触发后才需要加载的图片。而我们如果直接写入中，不管是在内加载图片后面调用，还是在具体元素里写入路径引入图片，a-frame在加载时都会去下载这个图片，处理完后最后才会生成界面，造成不必要的等待和页面空白。这里我们使用js异步加载，即触发事件后再对src进行编辑写入。我们demo里有个照片墙，点击进入后才会展示十几张照片。这种优化能很大的提高用户体验。3、为了代码简洁美观，推荐使用存放静态资源信息、等。 奇葩的video现在a-frame官方提供的video demo和我找到的video demo就是简单的电影播放功能，甚至连play、pause控制方法都没有明确的示例。想要一个电影屏幕的点击播放和暂停的控制，按照官网的api来开发，发现报错或者不管用。 首先先介绍下需求： 展示墙上两个video的静态图片，这个直接用jpg就可以搞定。 绑定事件，点击后进入播放状态： 点击返回就回到上一界面。下次点开继续播放。 然后问题就出现了。如果把video的资源放入中，那么及时实际的dom元素里没引入，也会自动下载播放这个视频。如果将video放到触发事件后再加入，第一次播放正常了，点击返回后video还是没控制关闭，继续在播放。哭~ 最后发现，video非常奇葩的把控制权放到了静态资源中。什么意思呢？就是需要在中引入video静态资源，实际中引入src为这个静态资源，但是js中事件触发控制的不是进行play()或者pause()，而是获取到这个静态资源进行play()或者pause()。这个和一般的使用方法有区别，导致出现前面控制不了的情况。 12345678&lt;a-assets&gt; &lt;img id=\"magic-i\" src=\"/asset/images/magic.jpg\"&gt; &lt;video id=\"magic-v\" src=\"/asset/video/magic.mp4\"&gt;&lt;/video&gt;......&lt;/a-assets&gt;......&lt;a-videosphere mixin=\"video\" autoplay=\"false\"&gt;&lt;/a-videosphere&gt;...... js代码： 123456......var videoSphere = document.querySelector('a-videosphere');......videoSphere.setAttribute('src', '#'+id+'-v');document.querySelector('#'+id+'-v').play();...... visible我们的这个示例demo涉及到很多场景的切换，这里我使用的是对元素visible的设置。一个场景用一个大的包裹，通过控制这些父元素的隐藏展现来实现场景的切换。但是会遇到这么个问题：父元素隐藏，但是实际上鼠标在移动的过程中，隐藏的物体还是会触发事件，会遮挡实际应该展现的元素的事件触发。 有人认为尽量不使用visible，而是使用opacity来控制展现隐藏。但是在涉及父元素控制整个场景的隐藏时opacity不能控制里面的元素。所以我还是用的visible。同时为了避免前面说到的问题，隐藏元素会整个的挪动位置，展现时再把位置挪动回来。","tags":[]},{"title":"hexo搭建博客","date":"2017-04-11T08:46:24.000Z","path":"2017/04/11/hexoBlog/","text":"13年想搭建一个个人博客，考虑到博客的内容简单，加上没钱没技术，调研过wordpress，嫌弃臃肿，还需要管理数据库，最后还是决定使用jekyll+github方式搭建个人博客。不过在使用jekyll的过程中也有一些问题和不爽的地方，尤其markdown方式写博客内容，没有GUI界面等，都是体验不好的地方。 所以当发现hexo时，我眼前一亮。nodeJs静态博客不就是目前最适合我的一款嘛！作为一个常用nodeJs+webpack+es6+react……开发项目的前端程序员来说，这个好像还蛮符合我的style的~So，我开始了hexo+git的个人博客改造。 环境搭建： 安装node：我的node版本是6.9.1 安装git：我的版本是1.8.4ps：系统：win7 64位；编辑器：sublime或者webstorm。 Github配置：因为是系统改造，之前已经申请了Github账号和Github pages了。这里只对添加SSH-Key做介绍：为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1、首先检查本机是否存在的ssh密钥 1$ cd ~/. ssh #检查本机已存在的ssh密钥 结果，(⊙o⊙)…，发现之前已经生成过了。在github个人账户首页-Settings-SSH and GPG keys看到了我的SSH秘钥，“Added on 28 Apr 2016 by GitHub for Windows. Never used”。汗颜一个~还没生效。 然后我在C:\\Users\\用户名中找到了.ssh文件。既然当时没弄清楚，现在删除重新搞一下吧~ 删除了.ssh文件，在Github上点击ssh的delete按钮。 1ssh-keygen -t rsa -C \"邮件地址\" 三个回车即可生成。第一个回车处可以设置存放生成ssh的地址。直接回车就放在默认C:\\Users\\用户名.ssh中 打开C:\\Users\\用户名.ssh中找到id_rsa.pub文件，打开复制代码粘贴到github-new ssh key中。title自己写一个。测试是否成功 1ssh -T git@github.com 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12git config --global user.name \"xxx\"// 你的github用户名，非昵称git config --global user.email \"xxx\"// 填写你的github注册邮箱 再次查看github密钥：登陆到github上查看刚刚输入的SSH key，现在图标的颜色变为绿色，说明密钥配置有效 hexoHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。官网： http://hexo.iogithub: https://github.com/hexojs/hexo 注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 全局安装hexo： 1npm install -g hexo 初始化hexo工程：在本地存放博客工程的文件夹地址下运行初始化hexo语言1hexo init hexo会自动下载一些文件，目录结构如图： 生成静态页面：1hexo generate 或者1hexo g 本地启动：1hexo server 或者1hexo s 浏览器访问http://localhost:4000/ 修改主题：界面主题不满足个人审美，所以，下一步是修改主题。网上查到这一款和我现有的主题很相似，ok，直接用它试试：hexo-theme-yilia 下载主题到文件夹themes/yilia中：1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。据说对手机端展示也做好了自适应。 配置_config.yml：有两处配置：一个是根目录下，一个是yilia下，配置完后重新hexo g生成，hexo s运行就能看到新的效果界面了。具体配置项自己修改~ 这里有个注意点：在所有文章点开处出现指导要求运行1npm i hexo-generator-json-content --save 但是按照步骤运行和添加代码后报错。解决方法：在node_modules/hexo-generator-json-content目录下，把里面的index.js文件的第一行加入:1\"use strict\"; 即可成功。ps：这句npm命令一样要在git里面运行才有效。 写文章：因为是旧的博客转移，所以要将旧的md博客修改过来。因为Hexo 支持 GitHub Flavored Markdown 的所有功能。原来md的写法和样式需要做一些调整~所以就是一些体力劳动了~~将md文件放入根目录下\\source_posts里。一般完整格式如下： 12345678---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面--- 以下是正文 当然，也可以通过命令来新建。1hexo new 'my-first-blog' 在合适的位置加上可以使前面的文字内容作为概要展现在文章列表里，否则全部文章展现在列表里就太长了。 另外，由于是技术文章，有些文章内需要增加css定义，script脚本。尤其是css定义，这里写…时要注意缩进。前后需要空行，否则语法识别有误会自动加上。 上传博客代码：1hexo deploy 然后发现报错deployer not found: git运行：npm install hexo-deployer-git –save之后就ok啦","tags":[]},{"title":"WebVR之A-Frame开发分享","date":"2016-11-24T16:00:00.000Z","path":"2016/11/25/webvr/","text":"WebVR之A-Frame开发分享","tags":[]},{"title":"在win7上搭建react native android环境","date":"2016-05-11T16:00:00.000Z","path":"2016/05/12/react-native-android/","text":"首先，我的搭建参考了http://reactnative.cn/docs/0.25/android-setup.html#content和其他一些网站在安装过程中，遇到一些坑，各种调研，解决了一些问题，最终选择了一个最适合我自己的环境搭建方式。下面给大家介绍我的搭建过程，希望能帮助到大家。 1、安装JDK网上要求安装JDK1.8以上，这里需要说明：在开发项目中使用的是1.8版本以下的（例如1.7）旧版本时，只要在eclipse中进行需要版本的JDK配置，不会有影响。所以，我又安装了最新版本的JDK。 问题：查看版本号发现如下错误： 这里是因为在Windows/System32文件夹里面当时复制了1.7的三个exe文件（java.exe, javaw.exe 和javaws.exe）进来。只需要将新的jdk路径/bin内的这三个exe复制替换到System32内就可以了。 2、安装Android SDK没安装的用户可以从官网下载，这里国内用户推荐从AndroidDevTools下载。 另外，这里需要说明，官网现在的下载包是包含了eclipse的IDE集成开发环境（Android Studio ），我不需要，后面安装完后可单独卸载Studio。为了提高下载速度，选择AndroidDevTools的Android Studio 2.0正式版的android-studio-bundle-143.2739321-windows.exe。（ide和bundle的区别就在于ide不含SDK Tools，我们需要bundle。） 安装过程傻瓜式，需要注意一点：如果你不想使用Google自己的模拟器，这里要勾掉。 我把这里勾掉了，因为后面安装的Genymotion（第三方模拟器）比Google的更好用哦。再有就是可以自己设置安装的路径。 下面就是一段时间的安装过程。安装完成后不打开studio。接下来修改定义环境变量吧！ps：由于我之前定义过JDK、SDK的环境变量，现在都有改变，所以都要做修改。 3、定义环境变量打开控制面板，选择系统和安全-&gt;系统-&gt;高级系统设置-&gt;高级-&gt;环境变量 系统变量里增加ANDROID_HOME：变量名填写ANDROID_HOME，变量值填写sdk的位置（D:\\DevTool\\android\\sdk）。在Path中增加%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools修改环境变量JAVA_HOME：C:\\Program Files\\Java\\jdk1.8.0_91这里我在系统变量 的Path里配置的JDK是这样的：%JAVA_HOME%\\bin;所以只要改JAVA_HOME就可以了。CATALINA_HOME里也一样统一使用%JAVA_HOME%：%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME% \\lib\\dt.jar; 4、安装React-native-cli1npm install -g react-native-cli 5、初始化项目，项目名称自定义。创建一个workspace文件夹存放项目，在改地址内cmd输入： 1react-native init MyReactNative 6、运行packager1react-native start 这里要进入自定义项目文件夹内 目前Windows下无法自动打开chrome进行调试，所以手动打开chrome，访问如下地址：http://localhost:8081/debugger-ui 即可。 7、安装GenymotionGenymotion是一个第三方模拟器，它比Google官方的模拟器更易设置且性能更好。但是，它只针对个人用户免费。 下载并安装Genymotion。在genymotion中添加一个模拟设备，之后在settings中设置模拟器的sdk为当前环境的sdk地址点击Start启动模拟器 8、启动android项目在项目文件夹地址内cmd运行： 1react-native run-android 报错如下： 网上说解决办法就是安装Android-23。但是其实我是安装了api 23的，被这个问题困扰了很久，更新了sdk，stidio都没用。后来删除了工程文件，重新下载后运行react-native run-android ，这个问题就解决了。可能是我在Android Studio导入项目时把build.gradle里面的内容给自动修改了。 不过继续出现新的错误： 打开sdk manager，安装23.0.1版本的Android SDk Build Tools，原来我之前装的是23.0.3的。重新运行后就ok了。汗，果然要注意，这里一定要按照版本要求，23.0.1。接下来就ok了，启动成功！","tags":[]},{"title":"webpack分享","date":"2016-03-06T16:00:00.000Z","path":"2016/03/07/webpack/","text":"webpack分享","tags":[]},{"title":"Cache","date":"2015-09-22T16:00:00.000Z","path":"2015/09/23/cache/","text":"上一章我们讨论了Cookie的概念和js使用方法。这一章我们来讨论Cache：一个同样在开发过程中经常听到的名词——缓存。 Cache是什么？缓存就是用来避免频繁的到主存储器（一般来说可能是数据库，结构化的磁盘文件，远程网络接口，程序接口等等提供数据返回的）获取数据而建立的一个存取更快的临时存储器（缓存）。一般来说，缓存比主存储器更小（不一定，也可能是存储的数据结构不一样，但是存取速度非常快），存储的容量也比较小，但是存取速度非常快。 简而言之，缓存一般有下面3个作用： 存储频繁访问的数据临时存储耗时的计算结果内存缓存减少磁盘IO Cache的类型我们会听到各种人说到缓存，但是大家讨论的缓存是有很大区别的。为什么呢？因为在整个系统开发的各个部分，缓存都担任着重要的角色。不同开发所说的缓存，是不同类型的缓存。缓存大致可以分为下面几种： 数据库端缓存数据库端缓存可以用“空间换时间”来比喻。比如建一个表来存储另外一个表某个类型的数据的总条数，在每次更新数据的时候更新 数据表和统计条数的表。在需要获取某个类型的数据的条数的时候，就不需要select count去查询，直接查询统计表就可以了，这样可以提高查询的速度和数据库的性能。 应用层缓存我们也经常从和前端接口的业务研发人员（RD）口中听到缓存这个词。应用层缓存也可以叫做服务器端缓存。有以下几种： 缓存数据库的查询结果，减少数据的压力。这个在大型网站是必须做的。缓存磁盘文件的数据。比如常用的数据可以放到内存，不用每次都去读取磁盘，特别是密集计算的程序，比如中文分词的词库。缓存某个耗时的计算操作，比如数据统计。 前端缓存我们这里说的前端缓存可以理解为一般使用的cdn技术，利用squid等做前端缓冲技术，主要还是针对静态文件类型，比如图片，css,js,html等静态文件。一般像天猫等用户量大的系统需要使用这个前端缓存。其实简而言之，就是为了让用户能快速的访问页面，将前端静态文件用缓存的方式分布全球各地，用户访问时可以就近下载，加快访问速度。 浏览器缓存浏览器端的缓存，可以让用户请求一次之后，下一次不在从服务器端请求数据，直接从本地缓存读取，可以减轻服务器负担也可以加快用户的访问速度。调试页面时强刷更新缓存指的就是客户端缓存，这里我们着重讨论浏览器端缓存。 浏览器缓存机制浏览器缓存分为两个部分： 页面html的缓存：HTTP协议定义的缓存机制（如： Expires； Cache-control等）。图片，css，js，flash等缓存：通过服务器配置实现将相应资源缓存在浏览器端。 主要讨论页面html缓存。 页面html缓存页面缓存状态是由http header决定的，一个浏览器请求信息，一个是服务器响应信息。主要包括Pragma: no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。其中Pragma: no-cache由HTTP/1.0规定，Cache-Control由HTTP/1.1规定。 从图中我们可以看到原理主要分三步：浏览器第一次请求，通过http的header报头，附带Expires，Cache-Control，Last-Modified/Etag向服务器请求，此时服务器记录第一次请求的Last-Modified/Etag；当浏览器再次请求的时候，附带Expires，Cache-Control，If-Modified-Since/Etag向服务器请求；服务器根据第一次记录的Last-Modified/Etag和再次请求的If-Modified-Since/Etag做对比，判断是否需要更新，然后响应请求。 这几个参数有什么作用呢？下面我们对这些参数进行说明： Cache-Control：值为Public，响应会被缓存，并且在多用户间共享；Private，响应只能够作为私有的缓存，不能再用户间共享；no-cache，不进行缓存；max-age=x，缓存时间，以秒为单位；must-revalidate，如果页面是过期的，则去服务器进行获取。Expires：设置显示页面的过期时间。Last-Modified：请求对象最后一次的修改时间，用来判断缓存是否过期，通常由服务器上文件的时间信息产生。If-Modified-Since：客户端发送请求附带的信息，指浏览器缓存请求对象的最后修改日期，用来和服务器端的Last-Modified做比较。Etag：ETag是一个可以与Web资源关联的记号（token），和Last-Modified功能才不多，也是一个标识符，一般和Last-Modified一起使用，加强服务器判断的准确度。","tags":[]},{"title":"Cookie","date":"2015-09-17T16:00:00.000Z","path":"2015/09/18/cookie/","text":"Cookie是什么？Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制，1994年作为 Mosaic Netscape 浏览器beta 0.9 版的一部分被引入。 那Cookie到底是用来做什么的呢？我们知道，Web应用程序是使用HTTP协议传输数据的。但是，HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接，这就意味着服务器无法从连接上跟踪会话。服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的作用。 目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。如果浏览器不支持Cookie（如大部分手机中的浏览器）或者把Cookie禁用了，Cookie功能就会失效。不同的浏览器采用不同的方式保存Cookie。IE浏览器会在“C:\\Documents and Settings\\你的用户名\\Cookies”文件夹下以文本文件形式保存，一个文本文件保存一个Cookie。 Cookie的传递流程当在浏览器地址栏中键入了一个Web站点的URL——假设是Amazon网址，浏览器会向该Web站点发送一个读取网页的请求，并将结果在显示器上显示。这时该网页在你的电脑上寻找 Amazon网站设置的Cookie文件，如果找到，浏览器会把Cookie文件中的数据连同前面输入的URL一同发送到Amazon服务器。服务器收到 Cookie数据，就会在他的数据库中检索你的ID，你的购物记录、个人喜好等信息，并记录下新的内容，增加到数据库和Cookie文件中去。如果没有检测到Cookie或者你的Cookie信息与数据库中的信息不符合，则说明你是第一次浏览该网站，服务器的CGI程序将为你创建新的ID信息，并保存到数据库中。 Cookie是利用了网页代码中的HTTP头信息进行传递的，浏览器的每一次网页请求，都可以伴随Cookie传递，例如，浏览器的打开或刷新网页操作。服务器将Cookie添加到网页的HTTP头信息中，伴随网页数据传回到你的浏览器，浏览器会根据你电脑中的Cookie设置选择是否保存这些数据。如果浏览器不允许Cookie保存，则关掉浏览器后，这些数据就消失。Cookie在电脑上保存的时间是不一样的，这些都是由服务器的设置不同决定得。Cookie有一个Expires（有效期）属性，这个属性决定了Cookie的保存时间，服务器可以通过设定Expires字段的数值，来改变Cookie的保存时间。如果不设置该属性，那么Cookie只在浏览网页期间有效，关闭浏览器，这些Cookie自动消失，绝大多数网站属于这种情况。通常情况下，Cookie包含Server、Expires、Name、value这几个字段，其中对服务器有用的只是Name和value字段，Expires等字段的内容仅仅是为了告诉浏览器如何处理这些Cookies。 如下图所示，是Cookie工作原理图。 图片出自站长百科 Cookie的编程实现多数网页编程语言都提供了对Cookie的支持。如javascript、VBScript、Delphi、ASP、SQL、PHP、C#等。在这些面向对象的编程语言中，对Cookie的编程利用基本上是相似的，大体过程为：先创建一个Cookie对象（Object），然后利用控制函数对Cookie 进行赋值、读取、写入等操作。下面从前的javascript语言的角度讨论Cookie的编程实现。 首先需要了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 获取Cookie：1234var cookie = document.cookie;console.log(cookie);//你会发现是一串字符串，由许多“key=value;key=value;……”组成 获取Cookie内具体的值：1234567891011121314var cookie = document.cookie;//cookie是一串有规律的键值对组成的字符串，通过对字符串处理方式获取具体值function getCookie(name)&#123; var arr,reg=new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"); if(arr=document.cookie.match(reg))&#123; return unescape(arr[2]); &#125;else&#123; return null; &#125;&#125; 设置Cookie内具体的值：这里需要了解Cookie的有效期这个概念。到现在为止，所有的cookie都是单会话cookie，即浏览器关闭后这些cookie将会丢失，事实上这些cookie仅仅是存储在内存中，而没有建立相应的硬盘文件。 在实际开发中，cookie常常需要长期保存，例如保存用户登录的状态。这时就需要通过设置有效期来实现。12345678910var cookie = document.cookie;function setCookie(c_name,value,expiredays)&#123; var exdate=new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie = c_name + \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());&#125; 删除Cookie内具体的值：这里将有效期设置为过去时间就可以了。123456789function delCookie(name)&#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null)&#123; document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); &#125;&#125; 上面介绍完Cookie的几种增删改查基本处理方法，下面介绍两个可能会遇到的常用Cookie处理。 指定可访问Cookie的路径默认情况下，如果在某个页面创建了一个cookie，那么该页面所在目录中的其他页面也可以访问该cookie。如果这个目录下还有子目录，则在子目录中也可以访问。例如在www.xxxx.com/html/a.html中所创建的cookie，可以被www.xxxx.com/html/b.html或www.xxx.com/ html/ some/c.html所访问，但不能被www.xxxx.com/d.html访问。为了控制cookie可以访问的目录，需要使用path参数设置cookie，语法如下：123//cookieDir表示可访问cookie的目录,表示当前cookie仅能在cookieDir目录下使用。document.cookie=\"name=value; path=cookieDir\"; 指定可访问Cookie的主机名和路径类似，主机名是指同一个域下的不同主机，例如：www.google.com和gmail.google.com就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为： 12document.cookie=\"name=value; domain=cookieDomain\"; Cookie的安全问题Cookie欺骗Cookie记录着用户的帐户ID、密码之类的信息，如果在网上传递，通常使用的是MD5方法加密。这样经过加密处理后的信息，即使被网络上一些别有用心的人截获，也看不懂，因为他看到的只是一些无意义的字母和数字。然而，现在遇到的问题是，截获Cookie的人不需要知道这些字符串的含义，他们只要把别人的Cookie向服务器提交，并且能够通过验证，他们就可以冒充受害人的身份，登陆网站。这种方法叫做Cookie欺骗。Cookie欺骗实现的前提条件是服务器的验证程序存在漏洞，并且冒充者要获得被冒充的人的Cookie信息。目前网站的验证程序要排除所有非法登录是非常困难的，例如，编写验证程序使用的语言可能存在漏洞。而且要获得别人Cookie是很容易的，用支持Cookie的语言编写一小段代码就可以实现（具体方法见三），只要把这段代码放到网络里，那么所有人的Cookie都能够被收集。如果一个论坛允许HTML代码或者允许使用Flash标签就可以利用这些技术收集Cookie的代码放到论坛里，然后给帖子取一个吸引人的主题，写上有趣的内容，很快就可以收集到大量的Cookie。在论坛上，有许多人的密码就被这种方法盗去的。至于如何防范，目前还没有特效药，我们也只能使用通常的防护方法，不要在论坛里使用重要的密码，也不要使用IE自动保存密码的功能，以及尽量不登陆不了解底细的网站。 Flash的代码隐患Flash中有一个getURL（）函数，Flash可以利用这个函数自动打开指定的网页。因此它可能把你引向一个包含恶意代码的网站。打个比方，当你在自己电脑上欣赏精美的Flash动画时，动画帧里的代码可能已经悄悄地连上网，并打开了一个极小的包含有特殊代码的页面。这个页面可以收集你的Cookie、也可以做一些其他的事情，比如在你的机器上种植木马甚至格式化你的硬盘等等。对于Flash的这种行为，网站是无法禁止的，因为这是Flash文件的内部行为。我们所能做到的，如果是在本地浏览尽量打开防火墙，如果防火墙提示的向外发送的数据包并不为你知悉，最好禁止。如果是在Internet上欣赏，最好找一些知名的大网站。","tags":[]},{"title":"amcharts v.3开发小结","date":"2015-08-30T16:00:00.000Z","path":"2015/08/31/amcharts/","text":"amcharts是什么？前端开发过程中经常会遇到图表展示的需求，这里我们往往会借用成熟的外部组件来尽快的投入到项目的开发中去。现有的主流的图表组件有很多，amcharts就是其中一个。amCharts 是一款高级图表库，致力于 Web 之上的数据可视化支持。它支持的图表包括柱状图、条状图、线图、蜡烛图、饼图、雷达、极坐标图、散点图，甚至连燃烧图、金字塔图，都有支持。amCharts 库是一款完全独立的类库，不依赖任何其他第三方类库，就可以在网站上运行。该类库支持两个版本，商业授权版本和免费版本（在图上显示 amCharts 的商标和链接）。 总之，我们在经过调研后，结合项目需求等内因外因选择了amcharts这个组件。amcharts满足了产品大部分的需求。但是很多地方需要定制。那在解决这些特殊需求的过程中，这里我来总结一下amcharts在使用过程中需要注意的地方。希望能在大家开发学习过程中有所帮助。 免费 vs 样式需求前面提到，amcharts有免费版本和商业授权版本。在开发过程中我们选择的是免费版本。但是产品需求是要按照UED提供切图中图表样式进行展示。显然UED是不会在示意图中增加“JS chart by amCharts”这个链接的。我们又不能将其去掉（涉及版权问题），所以经过协商，需要调整这个链接的位置。 打开amcharts.js，可以看到都是压缩过的代码。可以搜索“JS chart by amCharts”，只有一个结果，这个结果附近的代码设置了这个链接相关信息。amcharts中设置了可配参数定位这个链接，所以一般情况下可以在开发过程中直接配置。但是由于我们的需求要求定制位置，所以需要修改位置的值。右下角是通过“bottom-right”来确定位置。搜索它结果唯一。这里我们将“m=d-f-3”改成“m=d-f+37”。另外在引用amcharts时设置”creditsPosition”:”bottom-right”。 定制图表样式默认的amcharts显然不能满足需求，所以图表中坐标的粗细，颜色，透明度，包括里面线段，柱状图等等的样式都需要进行重新设置。如下图所示是最终效果。 在工程中，这种全局的图表样式设置在一个全局变量中设置，在各个图表的创建时引用全局样式配置。配置代码如下：123456789101112131415161718192021222324252627282930var DEFAULT_CHART_OPTS = &#123; \"type\": \"serial\", \"theme\": \"light\", \"path\": \"xxx\", \"fontFamily\":\"Microsoft YaHei,Tahoma,Arial\", \"fontSize\": 12, \"chartCursor\": &#123; \"categoryBalloonEnabled\": false, \"cursorAlpha\": 0, \"graphBulletSize\": 1.2, \"graphBulletAlpha\": 0.8 &#125;, \"categoryAxis\": &#123; \"parseDates\": false, \"color\":\"#7d7d7f\", \"gridAlpha\": 0 &#125;, \"balloon\": &#123; \"borderThickness\": 1, \"verticalPadding\": 5, \"textAlign\":\"left\", \"maxWidth\":450 &#125;, \"creditsPosition\":\"bottom-right\", \"export\": &#123; \"enabled\": true, \"position\": \"bottom-right\" &#125;&#125;; 这里特别介绍下一些配置项： path：配置amcharts中使用的图片存放路径。fontFamily：默认字体fontSize：默认字号chartCursor：鼠标移动的动态效果设置。categoryBalloonEnabled：mouseover时是否在x轴上出现弹泡。cursorAlpha：垂直于x轴的各个点的坐标线的透明度，这里设置为0让其不显示。graphBulletSize：表示值的点mouseover时放大（缩小）的倍数。graphBulletAlpha：表示值的点mouseover时的透明度。 categoryBalloonEnabled为true时效果： cursorAlpha为1时效果： graphBulletSize为3时效果： graphBulletAlpha为0.2时效果： categoryAxis：x轴的坐标设置。parseDates：是否按照默认格式转换日期。color：坐标值的颜色。gridAlpha：x坐标垂直线的透明度 parseDates为true时效果： color为red时效果： gridAlpha为1时效果： balloon：值在mouseover时出现的弹泡的设置。borderThickness：弹泡边框厚度。verticalPadding：弹泡在垂直方向的padding值。textAlign：文字对齐方向，默认居中。maxWidth：弹泡的最大宽度。 borderThickness为3时效果： verticalPadding为30时效果： textAlign为right时效果： creditsPosition：前面已经说过，是“JS chart by amCharts”这个链接的位置。export：导出功能。这里我们仅仅定义了可用和位置。详细的功能可以参考官网，在本项目中深入使用。 一些特殊用法以上的基本定制内容在官网上都能找到。但是由于产品需求的特殊性，我在开发过程中还遇到了一些特殊用法。 弹泡内容定制：按照需求多条折线在同一个x轴下弹泡只展示一个，并且把所有点的信息集中在该弹泡里。最简单的做法是后端将数据处理成这种格式，这里讨论前端控制方法。将曲线图参数graphs数组中balloonText设置为””，则自动mouseover后不展示弹泡。通过逻辑生成全部信息的弹泡内容，设置graphs[0]即可。标题定制：在图表最下方对每条线进行了描述，这里不只是展现限定长度的标题内容，还需要完成鼠标移动到标题部分展现弹泡。在官网上没找到可以直接设置的设置项，多方调研，最后是这么解决的。在曲线图参数graphs数组中增加一个自定义命名项，值为mouseover后需要展示的定制弹泡内的内容。在使用this.chart = AmCharts.makeChart创建图表后，进行事件绑定。事件绑定方法为：this.chart.legend.addListener(“rollOverItem”, function(){xxx})。如下图示，是需求效果。 小结amcharts是一个很漂亮的图表组件，功能也十分强大，还有很多功能我们没有使用，等待我们研究使用。之前版本的amcharts使用一般是直接创建，并使用函数逐个配置。新版的从官网的demo就可以看出，推荐使用使用一个比较大的配置项，直接创建生成。写法和美观程度不同，功能却大致相同，另外样式包括默认样式有一些变化。总之，amcharts是一个值得推荐的图表组件。","tags":[]},{"title":"Javascript Promise技术","date":"2015-08-26T16:00:00.000Z","path":"2015/08/27/promise/","text":"Promise是什么Promise是抽象异步处理对象以及对其进行各种操作的组件。听起来很晦涩？没关系，我们慢慢分析。从字义层面解释，Promise对应未来的含义，正如音译普罗米修斯，含义为“先知”的希腊神话故事中的英雄。那“未来”和js有什么关系呢？Js开发者都知道，前端开发中有个非常重要的概念和技术：Ajax请求——Js中的异步操作。而Promise就是对类似的异步处理对象和处理规则进行规范化，并要求采用统一接口进行开发，否则就会报错。 Promise并不是从JavaScript中发祥的概念。它最初被提出是在E语言中， 是基于并列/并行处理设计的一种编程语言。ES6提出了很多新的Js规范，其中Promise就是一个非常引人注目的技术。下面我们简单的探讨和学习Javascript Promise技术。 浏览器支持桌面浏览器对Promise的支持如下： Promise如何让Ajax回调更加美丽？概念的描述可能对Promise的理解还是不深刻，这里我们对比下普通的Ajax写法和使用Promise对象的异步请求方法，这样更能有助于我们理解什么是Promise，以及为什么要使用Promise。 常见的ajax异步请求如下：1234567891011121314151617$.ajax(&#123; url: url1, success: function (data) &#123; //成功操作 $.ajax(&#123; url: url2, data: data, success: function (data) &#123; //...... &#125; &#125;); &#125;, error:function(e)&#123; //...... &#125; &#125;); 由上面代码可以看到开发过程中经常遇到的一个问题，多个异步请求需要按照一定的先后顺序嵌套使用。这种写法会导致多个回调函数嵌套，导致代码不够直观，就是常说的 Callback Hell。为了解决上述的问题，Promise 对象应运而生，在 EMCAScript 2015 当中已经成为标准。 那Promise会怎么做呢？1234567891011121314151617181920function First() &#123; ajax(&#123; url: url1, success: function(data) &#123; B(data); &#125; &#125;); &#125; function Second(data) &#123; ajax(&#123; url: url2, data: data, success: function(data) &#123; ...... &#125; &#125;); &#125; new Promise(First).done(Second); 这样就避免了多重回调嵌套了。 resolve和reject同样用示例来说明。首先，创建一个用Promise把XHR处理包装起来的名为 getURL 的函数。12345678910111213141516171819202122232425function getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;); &#125; // 运行示例 var URL = \"http://httpbin.org/get\"; getURL(URL).then(function onFulfilled(value)&#123; console.log(value); &#125;).catch(function onRejected(error)&#123; console.error(error); &#125;); 从代码可以看出，getURL函数只有在通过XHR取得结果状态为200时才会调用 resolve。也就是只有数据取得成功时，而其他情况（取得失败）时则会调用 reject 方法。resolve 方法可以使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，即then获取参数进行操作。reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作，即catch获取参数进行操作。所以getURL发送ajax请求如果数据收取成功，则会运行console.log(req.responseText)，否则运行console.error(new Error(req.statusText))。 Promise 的三种状态用new Promise 实例化的promise对象有以下三个状态： “has-resolution” - Fulfilled：resolve(成功)时。此时会调用 onFulfilled“has-rejection” - Rejected：reject(失败)时。此时会调用 onRejected“unresolved” - Pending：既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等 getURL例子中的then方法就是根据 Promise 对象的状态来确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）。三种状态逻辑关系如下图所示： then 和 catch上面的例子已经让我们认识了.then().catch()的链式写法，其实在Promise里可以将任意个方法连在一起作为一个方法链（method chain）。下面我们增加方法链长度：1234567891011121314151617181920212223function taskA() &#123; console.log(\"Task A\"); &#125;function taskB() &#123; console.log(\"Task B\"); &#125;function onRejected(error) &#123; console.log(\"Catch Error: A or B\", error); &#125;function finalTask() &#123; console.log(\"Final Task\"); &#125; var promise = Promise.resolve(); promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask); 上面代码中的promise chain的执行流程，如果用一张图来描述一下的话，像下面的图那样。我们可以这样理解： then：注册onFulfilled时的回调函数catch：注册onRejected时的回调函数 Promise.all 和 Promise.racePromise.all 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 .then 方法。这使得我们在开发过程遇到的异步请求全部完成后再进行操作的需求变得简单方便。 123456789101112131415161718192021222324252627282930313233343536373839function getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;); &#125; var request = &#123; comment: function getComment() &#123; return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse); &#125;, people: function getPeople() &#123; return getURL('http://azu.github.io/promises-book/json/people.json').then(JSON.parse); &#125; &#125;; function main() &#123; return Promise.all([request.comment(), request.people()]); &#125; // 运行示例 main().then(function (value) &#123; console.log(value); &#125;).catch(function(error)&#123; console.log(error); &#125;); 在上面的代码中，request.comment() 和 request.people() 会同时开始执行，而且每个promise的结果（resolve或reject时传递的参数值），和传递给 Promise.all 的promise数组的顺序是一致的。也就是说，这时候 .then 得到的promise数组的执行结果的顺序是固定的，即 [comment, people]。 接着我们来看看和 Promise.all 类似的对多个promise对象进行处理的 Promise.race 方法。它的使用方法和Promise.all一样，接收一个promise对象数组为参数。Promise.all 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理， 与之相对的是 Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。 12345678910111213141516171819// delay毫秒后执行resolve function timerPromisefy(delay) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve(delay); &#125;, delay); &#125;); &#125;// 任何一个promise变为resolve或reject 的话程序就停止运行 Promise.race([ timerPromisefy(1), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128) ]).then(function (value) &#123; console.log(value); // =&gt; 1 &#125;); 上面的代码创建了4个promise对象，这些promise对象会分别在1ms，32ms，64ms和128ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后， .then 注册的回调函数就会被调用，这时候确定状态的promise对象会调用 resolve(1) 因此传递给 value 的值也是1，控制台上会打印出1来。 小结这里我们对Promise 进行了大概的介绍，感兴趣的同学可以关注JavaScript Promise迷你书（中文版）","tags":[]},{"title":"3D Canvas技术","date":"2015-08-03T16:00:00.000Z","path":"2015/08/04/3dCanvas/","text":"3D Canvas技术","tags":[]},{"title":"使用canvas绘制时钟","date":"2015-03-30T16:00:00.000Z","path":"2015/03/31/Canvas-Clock/","text":"该浏览器不支持canvas,换一个吧~亲 var clock = document.getElementById('clock'); //建立绘图环境 var cxt = clock.getContext('2d'); //时钟绘制函数 function drawClock(x, y, radius){ cxt.clearRect(0, 0, x*2, y*2); //画表盘 cxt.beginPath(); cxt.strokeStyle = \"#40bca3\"; cxt.lineWidth = 10; cxt.arc(x, y, radius, 0, 360, false); cxt.stroke(); cxt.closePath(); //画刻度 for(var i=0; i12:hour-12; //画时针 cxt.save(); cxt.strokeStyle = \"#000\"; cxt.lineWidth = 8; cxt.translate(x, y); cxt.rotate(hour*30*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+60); cxt.lineTo(0,10); cxt.stroke(); cxt.closePath(); cxt.restore(); //画分针 cxt.save(); cxt.strokeStyle = \"#000\"; cxt.lineWidth = 5; cxt.translate(x, y); cxt.rotate(min*6*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+40); cxt.lineTo(0,10); cxt.stroke(); cxt.closePath(); cxt.restore(); //画秒针 cxt.save(); cxt.strokeStyle=\"#e84849\"; cxt.lineWidth = 2; cxt.translate(x, y); cxt.rotate(6*sec*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+30); cxt.lineTo(0,15); cxt.closePath(); cxt.stroke(); //画表中间的圆点 cxt.beginPath(); cxt.arc(0,0,5,0,360,false); cxt.closePath(); cxt.fillStyle = \"#fff\"; cxt.fill(); cxt.stroke(); cxt.closePath(); cxt.restore(); } setInterval(\"drawClock(120, 120, 100)\",1000); 下面是时钟绘制代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var clock = document.getElementById('clock'); //建立绘图环境 var cxt = clock.getContext('2d'); //时钟绘制函数 function drawClock(x, y, radius)&#123; cxt.clearRect(0, 0, x*2, y*2); //画表盘 cxt.beginPath(); cxt.strokeStyle = \"#40bca3\"; cxt.lineWidth = 10; cxt.arc(x, y, radius, 0, 360, false); cxt.stroke(); cxt.closePath(); //画刻度 for(var i=0; i&lt;12; i++)&#123; cxt.save(); cxt.translate(x, y);//设置原点 cxt.strokeStyle = \"#e84849\";//颜色 cxt.lineWidth = 7;//粗细 //弧度 cxt.rotate(i*30*Math.PI/180); cxt.beginPath(); cxt.moveTo(0, radius - 20); cxt.lineTo(0, radius - 10); cxt.stroke(); cxt.closePath(); cxt.restore(); &#125; //获取当前时间 var date = new Date(); var hour = date.getHours(); var min = date.getMinutes(); var sec = date.getSeconds(); hour = hour + min/60; hour?hour&gt;12:hour-12; //画时针 cxt.save(); cxt.strokeStyle = \"#000\"; cxt.lineWidth = 8; cxt.translate(x, y); cxt.rotate(hour*30*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+60); cxt.lineTo(0,10); cxt.stroke(); cxt.closePath(); cxt.restore(); //画分针 cxt.save(); cxt.strokeStyle = \"#000\"; cxt.lineWidth = 5; cxt.translate(x, y); cxt.rotate(min*6*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+40); cxt.lineTo(0,10); cxt.stroke(); cxt.closePath(); cxt.restore(); //画秒针 cxt.save(); cxt.strokeStyle=\"#e84849\"; cxt.lineWidth = 2; cxt.translate(x, y); cxt.rotate(6*sec*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-radius+30); cxt.lineTo(0,15); cxt.closePath(); cxt.stroke(); //画表中间的圆点 cxt.beginPath(); cxt.arc(0,0,5,0,360,false); cxt.closePath(); cxt.fillStyle = \"#fff\"; cxt.fill(); cxt.stroke(); cxt.closePath(); cxt.restore(); &#125; setInterval(\"drawClock(120, 120, 100)\",1000);","tags":[]},{"title":"有趣的CSS3新技术PPT","date":"2015-03-09T16:00:00.000Z","path":"2015/03/10/CSS3/","text":"有趣的CSS3新技术PPT","tags":[]},{"title":"CSS Blend Modes","date":"2015-01-15T16:00:00.000Z","path":"2015/01/16/CSS-Blend-Modes/","text":"什么是CSS混合模式（CSS Blend Modes）混合模式是指将上层的图像融入下层图像时采用的各种模式。根据您所选择的模式，你会看到不同的融合后的效果。混合模式主要是一组不同的方式，这些方式用来确定当一个元素与另一个（部分或完全地）重叠时，图像的最终色彩应该是怎样的。本质上，这些模式就是源层和背景层颜色用数学表达的函数——例如RGBA，其中所有通道的值都在0和1之间——每一个特定的像素返回一个最终的数学值，最终确定该像素的颜色。每个混合模式用来确定颜色所使用的精确公式可以参考规范。现在，我们就来看看CSS中提供的不同混合模式分别产生了什么样的效果。 下面是一个简单的css混合模式的例子： .clear{ clear:both; } #cssBlendDemo{ width:100%; height: 320px; } #cssBlendDemo div{ float: left; width:200px; height: 300px; } #cssBlendDemo .just-color{ background-color: red; } #cssBlendDemo .normal-image{ background-image: url(/img/test.jpg); } #cssBlendDemo .bg-blend { background-image: url(/img/test.jpg); background-color: red; background-blend-mode: multiply; } HTML代码1234567891011&lt;div id=\"cssBlendDemo\"&gt; &lt;div class=\"just-color\"&gt; &lt;/div&gt; &lt;div class=\"normal-image\"&gt; &lt;/div&gt; &lt;div class=\"bg-blend\"&gt; &lt;/div&gt; &lt;span class=\"clear\"&gt;&lt;/span&gt;&lt;/div&gt; CSS代码123456789101112131415161718192021222324.clear&#123; clear:both;&#125;#cssBlendDemo&#123; width:100%; height: 300px;&#125;#cssBlendDemo div&#123; float: left; width:200px; height: 300px;&#125;#cssBlendDemo .just-color&#123; background-color: red;&#125;#cssBlendDemo .normal-image&#123; background-image: url(/img/test.jpg);&#125;#cssBlendDemo .bg-blend &#123; background-image: url(/img/test.jpg); background-color: red; background-blend-mode: multiply;&#125;","tags":[]},{"title":"Drop Caps","date":"2015-01-13T16:00:00.000Z","path":"2015/01/14/Drop-Caps/","text":"Drop Caps（下坠大写字母）：起首的大写字母比文字字身要低，通常放在出版物的主要段落的开始处，约占二行到四行以上。下面是整理的几种方法： L orem ipsum dolor sit amet, consectetur adipiscing elit. Mauris tristique lobortis orci ac lacinia. Fusce eu purus eget diam vehicula auctor nec eu elit. Morbi consequat facilisis orci vel malesuada. Donec ultrices molestie sollicitudin. Aliquam pharetra libero enim. Donec et suscipit massa. Donec dui odio, dignissim non sodales et, tincidunt a sapien. Phasellus elit nibh, adipiscing sed blandit vel, interdum et arcu. 跨浏览器的方式（额外标记）HTML代码：12&lt;span style=\"float: left; color: #903; font-size: 75px; line-height: 60px; padding-top: 4px; padding-right: 8px; padding-left: 3px; font-family: Georgia; \"&gt;L&lt;/span&gt; orem ipsum dolor sit amet, consectetur adipiscing elit. Mauris tristique lobortis orci ac lacinia. Fusce eu purus eget diam vehicula auctor nec eu elit. Morbi consequat facilisis orci vel malesuada. Donec ultrices molestie sollicitudin. Aliquam pharetra libero enim. Donec et suscipit massa. Donec dui odio, dignissim non sodales et, tincidunt a sapien. Phasellus elit nibh, adipiscing sed blandit vel, interdum et arcu. CSS3方法（无额外标记）HTML代码1234&lt;p id=\"css3DropCapsP\"&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris tristique lobortis orci ac lacinia. Fusce eu purus eget diam vehicula auctor nec eu elit. Morbi consequat facilisis orci vel malesuada. Donec ultrices molestie sollicitudin. Aliquam pharetra libero enim. Donec et suscipit massa. Donec dui odio, dignissim non sodales et, tincidunt a sapien. Phasellus elit nibh, adipiscing sed blandit vel, interdum et arcu.&lt;/p&gt; CSS代码123#css3DropCapsP:first-letter &#123; float: left; color: #903; font-size: 75px; line-height: 60px; padding-top: 4px; padding-right: 8px; padding-left: 3px; font-family: Georgia; &#125;&lt;/style&gt; Drop Caps插件（无额外标记）Drop Caps插件，是一款很赞的下坠大写字母插件，支持多种字母语言配置，下坠字母占据几行配置等等，详情可见Drop Caps Demo","tags":[]},{"title":"Form表单提交详解(3)","date":"2014-03-31T16:00:00.000Z","path":"2014/04/01/form-submit3/","text":"MVC Controller中多个自定义类型的传入参数前面的所有示例代码中都有一个规律：在服务端读取浏览器提交的数据时，都会使用控件的name属性，基本上在Asp.net中就是这样处理。但是在MVC中，MS为了简化读取表单数据的代码，可以让我们直接在Controller的方法中直接以传入参数的形式指定，此时框架会自动根据方法的参数名查找对应的输入数据（当然也不止表单数据了）。下面举个简单的例子： 12345678910 &lt;form action=\"/Home/Submit\" method=\"post\"&gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"Name\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"Tel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/p&gt; &lt;/form&gt; Conntroller中的方法的签名：12345678 public ActionResult Submit(Customer customer)&#123;&#125;public ActionResult Submit(string name, string tel)&#123;&#125; 以上二种方法都是可以的，当然了，前者会比较好，但需要事先定义一个Customer类，代码如下：1234567 public class Customer&#123; public string Name &#123; get; set; &#125; public string Tel &#123; get; set; &#125;&#125; 如果表单简单或者业务逻辑简单，我们或许一直也不会遇到什么麻烦，以上代码能很好的工作。但是，如果哪天我们有了新的业务需要求，需要在这个表单中同时加上一些其它的内容，例如，要把业务员的资料也一起录入进去。其中业务员的实体类定义如下：1234567 public class Salesman&#123; public string Name &#123; get; set; &#125; public string Tel &#123; get; set; &#125;&#125; Controller的接口需要修改成：1234 public ActionResult Submit(Customer customer, Salesman salesman)&#123;&#125; 这时，HTML表单又该怎么写呢？刚好，这二个类的(部分)属性名称一样，显然，前面表单中的Name,Tel就无法对应了。此时我们可以将表单写成如下形式：1234567891011121314 &lt;form action=\"/Home/Submit\" method=\"post\"&gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"customer.Name\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"customer.Tel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;销售员名称: &lt;input type=\"text\" name=\"salesman.Name\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;销售员电话: &lt;input type=\"text\" name=\"salesman.Tel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/p&gt; &lt;/form&gt; 注意Controller方法中的参数名与HTML表单中的name是有关系的。 F5刷新问题并不是WebForms的错刚才说到了MVC框架，再来说说WebForms框架。以前时常听到有些人在抱怨用WebForms的表单有F5的刷新重复提交问题。在此我想为WebForms说句公道话：这个问题并不是WebForms本身的问题，是浏览器的问题，只是如果您一直使用WebForms的较传统用法，是容易产生这个现象的。那么什么叫做【传统用法】呢？这里我就给个我自己的定义吧：所谓的WebForms的传统用法是说：您的页面一直使用服务器控件的提交方式(postback)，在事件处理后，页面又进入再一次的重现过程，或者说：当前页面一直在使用POST方式向当前页面提交。那么如何避开这个问题呢？办法大致有2种： PRG模式(Post-Redirect-Get)，在事件处理后，调用重定向的操作Response.Redirect()，而不要在事件处理的后期再去给一些服务器控件绑定数据项了！建议：按钮事件只做一些提交数据的处理，将数据绑定的操作放在OnPreRender方法中处理，而不是写在每个事件中（遍地开花）。不过，这种方式下，可能伟大的ViewState就发挥不了太大的作用了，如果您发现ViewState没用了，在Web.config中全局关掉后，又发现很多服务器控件的高级事件又不能用了！嗯，杯具有啊。这个话题说下去又没完没了，到此为止吧，不过，千万不要以为这种方法是在倒退哦。 以Ajax方式提交表单，请继续阅读本文。 以Ajax方式提交整个表单前面一直在说”浏览器提交表单”，事实上我们也可以用JavaScript提交表单，好处也有很多，比如前面所说的F5刷新问题。以Ajax方式提交表单的更大好处它是异步的，还可以实现局部刷新，这些特性都是浏览器提交方式没有的。前面我提到表单在提交时，浏览器要实现的4个步骤，基本上用JS来完成这个操作也是一样的。但是，前面说的步骤好像很麻烦呢，有没有简单的方法来实现这个过程呢？嗯，有的，这里我将使用JQuery以及jquery.form.js这个插件来演示这个复杂过程的简单处理方案。示例用的HTML表单还是我前面用的代码，完全不需要修改：12345678910 &lt;form action=\"Handler1.ashx\" method=\"post\" &gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"CustomerName\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"CustomerTel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/p&gt;&lt;/form&gt; JS代码如下：12345678 $(function()&#123; $('form').ajaxForm(&#123; success: function(responseText)&#123; alert(responseText); &#125; &#125;);&#125;); 是的，就是这么简单，只要调用ajaxForm()就行了。你也可以传入任何$.ajax()能接受的参数。它的作用是：修改表单的提交方式，改成Ajax方式提交。最终当用户点击“提交”按钮时，此时不再是浏览器的提交行为了，而是使用Ajax的方式提交，提交的URL以及提交方法就是在FORM中指定的参数。如果您希望要用户点击某个按钮或者链接时，也能提交表单（不经过提交按钮），那么可以使用如下方法：12345678910 $(function()&#123; $(\"#btnId\").click(function()&#123; $('form').ajaxSubmit(&#123; success: function(responseText)&#123; alert(responseText); &#125; &#125;); &#125;);&#125;); 变化很小，只需要将ajaxForm修改成ajaxSubmit就OK了。 与ajaxForm()不同，调用ajaxSubmit()方法将会立即提交表单。","tags":[]},{"title":"Form表单提交详解(2)","date":"2014-03-31T16:00:00.000Z","path":"2014/04/01/form-submit2/","text":"多提交按钮的表单用过Asp.net WebForms框架的人可能都写过这样的页面：一个页面中包含多个服务端按钮。处理方式嘛，也很简单：在每个按钮的事件处理器写上相应的代码就完事了，根本不用我们想太多。不过，对于不理解这背后处理过程的开发人员来说，当他们转到MVC框架下，可能会被卡住：MVC框架中可没有按钮事件！即使用不用MVC框架，用ashx通用处理器的方式，也会遇到这种问题，怎么办？ 对于这个问题，本文将站在HTML角度给出二个最根本的解决办法。方法1：根据【成功控件】定义，我们设置按钮的name，在服务端用name来区分哪个按钮的提交：HTML代码12345678 &lt;form action=\"Handler1.ashx\" method=\"post\"&gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"CustomerName\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"CustomerTel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" name=\"btnSave\" value=\"保存\" /&gt; &lt;input type=\"submit\" name=\"btnQuery\" value=\"查询\" /&gt; &lt;/p&gt;&lt;/form&gt; 服务端处理代码1234567891011 // 注意：我们只要判断指定的name是否存在就可以了。if( string.IsNullOrEmpty(context.Request.Form[\"btnSave\"]) == false ) &#123; // 保存的处理逻辑&#125;if( string.IsNullOrEmpty(context.Request.Form[\"btnQuery\"]) == false ) &#123; // 查询的处理逻辑&#125; 方法2：我将二个按钮的name设置为相同的值（根据前面的成功控件规则，只有被点击的按钮才会提交），在服务端判断value，示例代码如下：123456789101112131415161718192021 &lt;form action=\"Handler1.ashx\" method=\"post\"&gt;&lt;p&gt;客户名称: &lt;input type=\"text\" name=\"CustomerName\" style=\"width: 300px\" /&gt;&lt;/p&gt;&lt;p&gt;客户电话: &lt;input type=\"text\" name=\"CustomerTel\" style=\"width: 300px\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=\"submit\" name=\"submit\" value=\"保存\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"查询\" /&gt;&lt;/p&gt;&lt;/form&gt;string action = context.Request.Form[\"submit\"];if( action == \"保存\" ) &#123; // 保存的处理逻辑&#125;if( action == \"查询\" ) &#123; // 查询的处理逻辑&#125; 当然了，解决这个问题的方法很多，我们还可以在提交前修改form.action属性。对于MVC来说，可能有些人会选择使用Filter的方式来处理。最终选择哪种方法，可根据各自喜好来选择。我可能更喜欢直接使用Ajax提交到一个具体的URL，这样也很直观，在服务端也就不用这些判断了。接着往下看吧。 上传文件的表单前面我说到“数据的编码”提到了form.enctype，这个属性正是上传表单与普通表单的区别，请看以下示例代码：1234567 &lt;form action=\"Handler2.ashx\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"str\" value=\"一个字符串，别管它\" /&gt;&lt;/p&gt; &lt;p&gt;要上传的文件１&lt;input type=\"file\" name=\"file1\"/&gt;&lt;/p&gt; &lt;p&gt;要上传的文件２&lt;input type=\"file\" name=\"file2\"/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/p&gt;&lt;/form&gt; 我将上传2个小文件：我们再来看看当我点击提交按钮时，浏览器发送的请求是个什么样子的：注意我用红色边框框出来的部分，以及请求体中的内容。此时请求头Content-Type的值发生了改变，而且还多了一个叫boundary的参数，它将告诉服务端：请求体的内容以这个标记来分开。 并且，请求体中每个分隔标记会单独占一行，且具体内容为：”–” + boundary，最后结束的分隔符的内容为：”–” + boundary + “–” 也是独占一行。从图片中我们还可以发现，在请求体的每段数据前，还有一块描述信息。 具体这些内容是如何生成的，可以参考本文后面的实现代码。 再来看看在服务端如何读取上传的文件。123456789 HttpPostedFile file1 = context.Request.Files[\"file1\"];if( file1 != null &amp;&amp; string.IsNullOrEmpty(file1.FileName) == false ) file1.SaveAs(context.Server.MapPath(\"~/App_Data/\") + file1.FileName);HttpPostedFile file2 = context.Request.Files[\"file2\"];if( file2 != null &amp;&amp; string.IsNullOrEmpty(file2.FileName) == false ) file2.SaveAs(context.Server.MapPath(\"~/App_Data/\") + file2.FileName); 或者12345678910 HttpFileCollection files = context.Request.Files;foreach( string key in files.AllKeys ) &#123; HttpPostedFile file = files[key]; if( string.IsNullOrEmpty(file.FileName) == false ) file.SaveAs(context.Server.MapPath(\"~/App_Data/\") + file.FileName);&#125; 二种方法都行，前者更能体现控件的name与服务端读取的关系，后者在多文件上传时有更好的扩展性。 安全问题：注意，上面示例代码中，这样的写法是极不安全的。正确的做法应该是：重新生成一个随机的文件名，而且最好能对文件内容检查，例如，如果是图片，可以调用.net的一些图形类打开文件，然后”另存”文件。总之，在安全问题面前只有一个原则：不要相信用户的输入，一定要检查或者转换。","tags":[]},{"title":"Form表单提交详解(1)","date":"2014-03-31T16:00:00.000Z","path":"2014/04/01/form-submit1/","text":"愚人节快乐！作为一个接触前端时间不长的人来说，jQuery等框架已经封装好了很多dom操作、ajax方法，大大简化了初学者的学习和开发成本。所以在接触一些旧的开发代码时，往往会觉得十分不明觉厉。例如，Form表单提交。Form表单提交，在jQuey中完全可以被模仿和取代，利用ajax方法传参给后端，简洁大方，清晰易懂（此处省略一万字）。但是，尤其是在面对旧系统，或者后端开发为主的系统（内部系统，无专业前端开发）时，你会发现Form表单方式来提交信息时非常普遍的。这个时候，我们要了解它的运行过程。下面，是我调研的Form表单内容，看完对这个知识点有了新的认识。希望能对大家有用。 Form表单是Asp.net WebForms框架为了帮助开发者简化开发工作，而做的完美的封装。它让开发者只需要简单地使用服务端控件就可以直接操作那些 HTML表单元素了。 简单的表单，简单的处理方式首先，看看下面这个简单的HTML表单：123456 &lt;form action=\"Handler1.ashx\" method=\"post\" &gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"CustomerName\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"CustomerTel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/p&gt; &lt;/form&gt; 在这个HTML表单中，我定义了二个文本输入框，一个提交按钮，表单将提交到Handler1.ashx中处理，且以POST的方式。注意哦，如果我们想让纯静态页面也能向服务器提交数据，就可以采用这样方式来处理：将action属性指向一个服务器能处理的地址。说明：当我们使用WebForms的服务器表单控件时，一般都会提交到页面自身来处理(action属性指向当前页面)，这样可以方便地使用按钮事件以及从服务器控件访问从浏览器提交的控件输入结果。如果在URL重写时，希望能在页面回传时保持URL不变，即：action为重写后的URL，那么可以Page类中执行以下调用：12 Form.Action = Request.RawUrl; // 受以下版本支持：3.5 SP1、3.0 SP1、2.0 SP1 好了，我们再回到前面那个HTML表单，看一下如果用户点击了“提交”按钮，浏览器是如何把表单的内容发出的。在此，我们需要Fiddler工具的协助，请在提交表单前启动好Fiddler。我将这个表单的提交请求过程做了如下截图。上图是将要提交的表单的输入情况，下图是用Fiddler看到的浏览器发出的请求内容。在这张图片中，我们可以看到浏览器确实将请求发给了我前面在action中指定的地址，且以POST形式发出的。表单的二个控件的输入值放在请求体中，且做了【编码】处理，编码的方式用请求头【Content-Type】说明，这样，当服务端收到请求后，就知道该如何读取请求的内容了。注意：表单的数据是以name1=value1&amp;name2=value2 的形式提交的，其中name,value分别对应了表单控件的相应属性。我们还可以在Fiddler中，将视图切换到WebForms选项卡，这样能更清楚地只查看浏览器提交的数据，如下图。看了客户端的页面和请求的内容，我们再来看看在服务端如何获取浏览器提交的表单的输入吧，代码如下：1234 string name = context.Request.Form[\"CustomerName\"]; string tel = context.Request.Form[\"CustomerTel\"]; 代码很简单，直接根据表单控件的name属性访问Request.Form就可以了。 表单提交，成功控件我们再来看一下浏览器是如何提交表单的，或者说，浏览器在提交表单时，要做哪些事情。浏览器并不是将所有的表单控件全部发送到服务器的，而是会查找所有的【成功控件】，只将这些成功控件的数据发送到服务端，什么是成功控件呢？简单地来说，成功控件就是：每个表单中的控件都应该有一个name属性和”当前值“，在提交时，它们将以 name=value 的形式做为提交数据的一部分。对于一些特殊情况，成功控件还有以下规定： 控件不能是【禁用】状态，即指定【disabled=”disabled”】。即：禁用的控件将不是成功控件。 如果一个表单包含了多个提交按键，那么仅当用户点击的那个提交按钮才算是成功控件。 对于checkbox控件来说，只有被用户勾选的才算是成功控件。 对于radio button来说，只有被用户勾选的才算是成功控件。 对于select控件来说，所有被选择的选项都做为成功控件，name由select控件提供。 对于file上传文件控件来说，如果它包含了选择的文件，那么它将是一个成功控件。此外，浏览器不会考虑Reset按钮以及OBJECT元素。 注意： 对于checkbox, radio button来说，如果它们被确认为成功控件，但没有为控件指定value属性，那么在表单提交时，将会以”on”做为它们的value 如果在服务端读不到某个表单控件的值，请检查它是否满足以上规则。 提交方式：在前面的示例代码中，我为form指定了method=”post”，这个提交方法就决定了浏览器在提交数据时，通过什么方式来传递它们。如果是【post】，那么表单数据将放在请求体中被发送出去。如果是【get】，那么表单数据将会追加到查询字符串中，以查询字符串的形式提交到服务端。建议：表单通常还是以post方式提交比较好，这样可以不破坏URL，况且URL还有长度限制。数据的编码：前面我将浏览器的请求细节用Fiddler做了个截图，从这个图中我们可以看到：控件输入的内容并不是直接发送的，而是经过一种编码规则来处理的。目前基本上只会只使用二种编码规则：application/x-www-form-urlencoded 和 multipart/form-data ，这二个规则的使用场景简单地说就是：后者在上传文件时使用，其它情形则使用前者(默认)。按照我前面说过的编码规则选择逻辑，application/x-www-form-urlencoded做为默认值，所以，一般情况下我们并不用显式指定。除非我们要上传文件了，那么此时必须设置enctype=”multipart/form-data”好了，说了这么一大堆理论，我们再来看一下浏览是如何处理表单数据的。这个过程大致分为4个阶段： 识别所有的成功控件。 为所有的成功控件创建一个数据集合，它们包含 control-name/current-value 这样的值对。 按照form.enctype指定的编码规则对前面准备好的数据进行编码。编码规则将放在请求中，用【Content-Type】指出。 提交编码后的数据。此时会区分post,get二种情况，提交的地址由form.action属性指定的。","tags":[]},{"title":"Form表单提交详解(4)","date":"2014-03-31T16:00:00.000Z","path":"2014/04/01/form-submit4/","text":"以Ajax方式提交部分表单在前面的示例中，我们看到以Ajax方式提交一个表单是非常容易的，它完全模拟了浏览器的行为。不过，有时我们可能需要只提交表单的一部分，为的是更好的局部更新，那么又该如何做呢？假如我有以下表单的一部分，我只希望在用户某个按钮时将它提交到服务端： 12345678 &lt;div id=\"divCustomerInfo\"&gt; &lt;p&gt;客户名称: &lt;input type=\"text\" name=\"CustomerName\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;p&gt;客户电话: &lt;input type=\"text\" name=\"CustomerTel\" style=\"width: 300px\" /&gt;&lt;/p&gt; &lt;/div&gt; 我们可以这样来提交这部分表单的数据：1234567891011121314 $(\"#btnId\").click(function()&#123; $.ajax(&#123; url: \"Handler1.ashx\", type: \"POST\", data: $('#divCustomerInfo :text').fieldSerialize(), success: function(responseText)&#123; alert(responseText); &#125; &#125;); return false;&#125;); 注意关键的代码行：data: $(‘#divCustomerInfo :text’).fieldSerialize()注意：此时将由您指定一个【JQuery选择器】来过滤要提交的控件，而不是使用成功控件的筛选逻辑。或者，您也可以使用下面将要介绍的方法，仍然是使用 data: {} 的方式，但需要手工指定数据成员。 使用JQuery，就不要再拼URL了！JQuery越来越流行，以至于在创建MVC项目时，VS IDE会把JQuery也准备好了，可能MS认为开发WEB项目离不开JQuery了。的确，JQuery非常方便，尤其是在处理DOM时，不仅如此，在处理AJAX请求时，也非常方便。不过，有件事却让我很纳闷：经常看到有人在使用JQuery实现Ajax时，把一堆参数放在URL中传递，当然了，发送GET请求嘛，这样做不错，但是，让我不解的是：URL是拼接起来的，而且代码又臭又长！如果是一个简单的参数：”aaa.aspx?id=” + xxId ，这样也就罢了。但是当一堆参数拼接在一起时，可能一下子还看不清楚到底有几个什么样的参数。而且经验丰富一些的开发人员会发现这样做有时会有乱码问题，可能网上搜过后，知道还有编码的工作要处理，于是又加了一堆编码方法。到此为止，这段代码会让人看起来很累！ 如果您平时也是这样做的，那么我今天就告诉您：不要再拼接URL了！ $.ajax()的参数不是有个data成员嘛，用它吧。看代码： 123456789 $.ajax(&#123; url: \"Handler1.ashx\", type: \"POST\", data: &#123; id: 2, name: \"aaa\", tel: \"~!@#$%^&amp;*()_+-=&lt;&gt;?|\", xxxx: \"要多少还可以写多少\", encoding: \"见鬼去吧。?&amp; :)\" &#125;, success: function(responseText) &#123; $(\"#divResult\").html(responseText); &#125;&#125;); 你说什么，只能使用GET ？ 哦，那就改一下 type 参数吧。 123456789 $.ajax(&#123; url: \"Handler1.ashx\", type: \"GET\", data: &#123; id: 2, name: \"aaa\", tel: \"~!@#$%^&amp;*()_+-=&lt;&gt;?|\", xxxx: \"要多少还可以写多少\", encoding: \"见鬼去吧。?&amp; :)\" &#125;, success: function(responseText) &#123; $(\"#divResult\").html(responseText); &#125;&#125;); 看了这个示例，您还会继续拼URL吗？说明：为了排版简单，我将参数放在一行了，建议实际使用时，不要挤在一行。 id, name 有什么关系通常我们在写HTML代码时，会给控件指定一个id属性，这个属性只供JS和CSS使用，在表单提交时，它不起任何作用。在上面的示例代码中，可能data {}中的各个value就来源于各个不同的控件，那么为那些控件指定相应的id属性将会方便地找到它们。但是如果不需要用JS和CSS控制的控件，或许它们只是用来显示一些数据(只读)，那么就没有必要指定id属性，当然了，name属性也可以不用给出(避免提交无意义的数据)。–END 摘自：f​o​r​m​表​单​提​交​过​程","tags":[]},{"title":"Mootools调研(4)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report4/","text":"3.2 事件管理Element.Event，提供事件的包装，元素绑定事件机制；Element.Delegation，提供事件委托机制, 即把一个(动态)子元素上的事件处理绑定委托到父容器上。都可在core文件中查看源码。下面介绍几个常用的事件管理方法：MooTools已经提供了window对象的自定义事件: ‘domready’。 MooTools就是用window.addEvent(‘domready’, function() {})方式来代替传统JavaScript的window.onload 方法的。 该事件在页面的DOM树加载完成后触发 在需要保证所要操作的DOM元素已经加载完成的情况,本事件将非常有用 本事件只对window对象有效 默认的情况下所有的代码都应该包含在‘domready’事件监听下。在文档完成后，如果向一个元素添加一个事件监听器的方法是：addEvent()方法。第一个参数是事件类型，包括：12345678910111213 Element.NativeEvents = &#123; click: 2, dblclick: 2, mouseup: 2, mousedown: 2, contextmenu: 2, //mouse buttons mousewheel: 2, DOMMouseScroll: 2, //mouse wheel mouseover: 2, mouseout: 2, mousemove: 2, selectstart: 2, selectend: 2, //mouse movement keydown: 2, keypress: 2, keyup: 2, //keyboard orientationchange: 2, // mobile touchstart: 2, touchmove: 2, touchend: 2, touchcancel: 2, // touch gesturestart: 2, gesturechange: 2, gestureend: 2, // gesture focus: 2, blur: 2, change: 2, reset: 2, select: 2, submit: 2, paste: 2, input: 2, //form elements load: 2, unload: 1, beforeunload: 2, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window error: 1, abort: 1, scroll: 1 //misc&#125;; addEvents()方法允许您添加多个事件监听到一个元素（或元素的集合）。MooTools 的灵活性之一就是可以自由的扩展，我们也可以创建自己的自定义事件。我们只需要给 Element.Events 对象扩展相应的属性就可以自定义事件了。示例如下：1234567891011121314 Element.Events.eventname = &#123; 'base' : 'click', // A base event such as click, keypress, keydown, onload, etc. 'condition' : function() &#123; // conditions that need to be met to trigger event &#125;, 'onAdd' : function() &#123; // Functions to trigger when you bind/add the event to elements &#125;, 'onRemove' : function() &#123; // Functions to execute when you unbind/remove elements &#125;&#125;; 自定义一个事件时，Element.Events.eventname中可包含如下内容： base：(string, 可选) 自定义事件所监听的基类事件. 如果指定了下面condition参数,则本参数必须填写condition：(function, 可选) 自定义事件触发的条件函数 (函数的参数为一个Event实例)onAdd：(function, 可选) 当元素添加自定义事件时触发的函数 (函数的参数为一个Event实例)onRemove：(function, 可选) 当元素删除自定义事件时触发的函数 (函数的参数为一个Event实例) removeEvent()方法，它移除了一个指定的事件。如果你想删除一个元素的事件类型（或一组元素的事件类型），或者删除所有的事件，你必须使用removeEvents()方法。使用cloneEvents()来克隆目标元素上的所有事件到本元素 。 3.3 扩展方式也可以扩展window类或者已有函数。另外，Mootools中定义了一个Event类，它提供了对原始window的事件对象event的扩展，使用的时候，可以 把原来的event对象作为Event的构造方法参数传入：12 var event = new Event(event); 这样，返回的event就包含了所有mootools经过扩展的功能，具体扩展的属性和方法如下：12345678 $('myLink').onkeydown = function(event)&#123; var event = new Event(event); //扩展了的event alert(event.shift); //如果按下的按键是shift,则alert结果为true&#125;; 插件扩展一般使用new Class方式或者全局自动生成的方式。例如下面的Namespace插件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161 /*---Script: Namespace.class.jsAuthor: Eric Clemmons &lt;eric@smarterspam.com&gt;Description: Allows for slightly new Class instantiations for name.spacingRequires:- core/Class.Extras- core/RequestProvides: [Namespace]License: MIT-style*/var Namespace = new Class(&#123; Implements: Options, options: &#123; root: window, // You can set the base for your namespace. Defaults to `window` delimiter: \".\" // Delimiter for namespacing &#125;, // Accepts the namespace path \"my.namespace.path\" &amp; the class options for instantiation initialize: function(namespace, options) &#123; if (options.namespace) &#123; this.setOptions(options.namespace); &#125;; // Parse options for strings where classes should exist options = this.parseOptions(options); // Return the instantiated class return this.getClass(namespace, options); &#125;, parseOptions: function(options) &#123; // Replace `Extends: \"myClass\"` with `Extends: myClass` instantiation var params = [\"Implements\", \"Extends\", \"Requires\"]; // Iterate through each type of dependency (i.e. \"Extends\") params.each(function(param) &#123; var resources = $splat(options[param]); resources.each(function(resource, i) &#123; // If the dependency isn't a class yet, try to load the class if ($type(resource) === \"string\") &#123; // Get existing class or load it via SJAX var resource = this.load(resource); // If class finally exists, assign it to it's key (for Requires) // or to the param itself (for Extends) if ($type(resource) === \"class\") &#123; if ($type(options[param]) === \"array\") &#123; options[param][i] = resource; &#125; else &#123; options[param] = resource; &#125; &#125; else &#123; if (param !== \"Requires\") &#123; throw new Error(param + \" class \\\"\" + resource + \"\\\" does not exist or could not be loaded.\"); &#125; &#125; &#125; &#125;, this); &#125;, this); return options; &#125;, // Traverses down the namespace path and returns the (newly instantiated if not existing) class getClass: function(namespace, options) &#123; var root = this.options.root; // Iterate through each section of the namespace namespace.split(this.options.delimiter).each(function(name, i, names) &#123; // Up until the last leaf, create an object if undefined if (i &lt; names.length - 1) &#123; if (!root[name]) &#123; root[name] = &#123;&#125;; &#125; &#125; else &#123; // If the last leaf doesn't exist &amp; we're looking to instantiate, instantiate the class if (!root[name] &amp;&amp; options) &#123; return root[name] = new Class(options); &#125; &#125;; root = root[name]; &#125;); // Return the requested namespaced class return root; &#125;, load: function(namespace) &#123; (new Request(&#123; url: Namespace.getBasePath(namespace) + \".js\", method: 'GET', async: false, evalResponse: true &#125;)).send(); return this.getClass(namespace); &#125; &#125;);Namespace.paths = &#123; _base: \".\"&#125;;Namespace.setBasePath = function(namespace, path) &#123; if (!path) &#123; var path = namespace; var namespace = \"_base\"; &#125; Namespace.paths[namespace] = path;&#125;;Namespace.getBasePath = function(namespace) &#123; // Start with the base path var path = Namespace.paths._base; // Iterate through each specified namespace path (\"Moo.Core\" =&gt; \"js/Moo/Core/Source\") for (var stub in Namespace.paths) &#123; if (stub === namespace.substring(0, stub.length)) &#123; path += \"/\" + Namespace.paths[stub]; // Remove stub from namespace, as we've already pathed it namespace = namespace.substring(stub.length + 1); break; &#125; &#125; return path + \"/\" + namespace.replace(/\\./g, \"/\");&#125;;Namespace.require = function(namespaces) &#123; $splat(namespaces).each(function(namespace) &#123; new Namespace(namespace, &#123; Requires: namespace &#125;); &#125;);&#125;;// Initialize base path based on Namespace script &amp; document URL;(function() &#123; // Get the last script loaded (should be this script) var script = $$('script').getLast(); // Trim off the script name var jsUrl = script.src.substring(0, script.src.lastIndexOf(\"/\")); // Trim off the page name as well var baseUrl = document.URL.substring(0, document.URL.lastIndexOf(\"/\") + 1); // Subtract page path from script path to get script subfolder var path = jsUrl.replace(baseUrl, ''); Namespace.setBasePath(path);&#125;)();","tags":[]},{"title":"Mootools调研(3)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report3/","text":"3 功能3.1 OOP继承类的实现和扩展MooTools框架的core中定义了class方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 /*---name: Classdescription: Contains the Class Function for easily creating, extending, and implementing reusable Classes.license: MIT-style license.requires: [Array, String, Function, Number]provides: Class...*/(function()&#123;var Class = this.Class = new Type('Class', function(params)&#123; if (instanceOf(params, Function)) params = &#123;initialize: params&#125;; var newClass = function()&#123; reset(this); if (newClass.$prototyping) return this; this.$caller = null; var value = (this.initialize) ? this.initialize.apply(this, arguments) : this; this.$caller = this.caller = null; return value; &#125;.extend(this).implement(params); newClass.$constructor = Class; newClass.prototype.$constructor = newClass; newClass.prototype.parent = parent; return newClass;&#125;);var parent = function()&#123; if (!this.$caller) throw new Error('The method \"parent\" cannot be called.'); var name = this.$caller.$name, parent = this.$caller.$owner.parent, previous = (parent) ? parent.prototype[name] : null; if (!previous) throw new Error('The method \"' + name + '\" has no parent.'); return previous.apply(this, arguments);&#125;;var reset = function(object)&#123; for (var key in object)&#123; var value = object[key]; switch (typeOf(value))&#123; case 'object': var F = function()&#123;&#125;; F.prototype = value; object[key] = reset(new F); break; case 'array': object[key] = value.clone(); break; &#125; &#125; return object;&#125;;var wrap = function(self, key, method)&#123; if (method.$origin) method = method.$origin; var wrapper = function()&#123; if (method.$protected &amp;&amp; this.$caller == null) throw new Error('The method \"' + key + '\" cannot be called.'); var caller = this.caller, current = this.$caller; this.caller = current; this.$caller = wrapper; var result = method.apply(this, arguments); this.$caller = current; this.caller = caller; return result; &#125;.extend(&#123;$owner: self, $origin: method, $name: key&#125;); return wrapper;&#125;;var implement = function(key, value, retain)&#123; if (Class.Mutators.hasOwnProperty(key))&#123; value = Class.Mutators[key].call(this, value); if (value == null) return this; &#125; if (typeOf(value) == 'function')&#123; if (value.$hidden) return this; this.prototype[key] = (retain) ? value : wrap(this, key, value); &#125; else &#123; Object.merge(this.prototype, key, value); &#125; return this;&#125;;var getInstance = function(klass)&#123; klass.$prototyping = true; var proto = new klass; delete klass.$prototyping; return proto;&#125;;Class.implement('implement', implement.overloadSetter());Class.Mutators = &#123; Extends: function(parent)&#123; this.parent = parent; this.prototype = getInstance(parent); &#125;, Implements: function(items)&#123; Array.from(items).each(function(item)&#123; var instance = new item; for (var key in instance) implement.call(this, key, instance[key], true); &#125;, this); &#125;&#125;;&#125;)(); 从中可以看出，参数可以传两种。第一种也是标准方式传递一个对象字面量，这个对象字面量可以包括你为类添加的所有属性、方法。1234567891011121314var Person = new Class(&#123; // Methods initialize: function (name, age) &#123; this.name = name; this.age = age; &#125;, log: function () &#123; console.log(this.name + ',' + this.age); &#125; &#125;); var mark = new Person('mark', 24); mark.log(); // returns 'mark,24' 第二种是传递一个普通函数，mootools会自动把这个函数包装成只含一个initialize键值的对象字面量，然后你可以使用implement方法对类进行扩展，例如：123456789101112 var Person = new Class(function (name, age) &#123; this.name = name; this.age = age; &#125;); Person.implement('log', function () &#123; console.log(this.name + ',' + this.age); &#125;); var mark = new Person('mark', 24); mark.log(); // returns 'mark,24' core中定义了Implement方法。这个方法用来为类添加新的方法和属性。需要注意的是，如果新添加的方法或属性与类中旧有的方法或属性同名，则会覆盖类中旧有的方法、属性。调用Implement方法有两种方式，第一种方式传递两个参数，第一个参数为String类型，存储要添加的方法或属性的名称，第二个参数为方法所对应的函数或属性所对应的值，这种方式每次只能为类添加一个方法或属性，第二种方式传递一个对象字面量参数，把要添加的方法属性包含在这个对象中，一次添加多个方法、属性，避免重复调用implement。方法调用示例：123456 Person.implement('log', function () &#123; console.log(this.name + ',' + this.age); &#125;); Person.implement('city', '深圳'); 1234567 Person.implement(&#123; 'city': '深圳', 'log': function () &#123; console.log(this.name + ',' + this.age); &#125; &#125;); MooTools关于Class的官方文档中只暴露了implement一个方法，其实对类本身进行操作的还有一个比较重要的方法extend，这个方法之所以没有出现在Class的文档中。这是因为它不是作为Class的特殊方法，而实际上是Type的方法。它的作用是为类创建静态成员，静态成员关联的是类本身，换句话说，静态成员是在类的层次上操作，而不是在实例的层次上操作，每个静态成员都只有一份。调用extend方法的方式同Implement，也是两种方式。简单一点讲，implement为实例创建方法和属性，extend为类本身创建方法和变量，请看下面的例子：1234567891011121314151617181920212223242526272829 var Person = new Class(function (name, age) &#123; this.name = name; this.age = age; &#125;); Person.implement(&#123; instanceMethod: function () &#123; console.log('From an instance!'); &#125; &#125;); Person.extend(&#123; classMethod: function () &#123; console.log('From the class itself!'); &#125; &#125;); var mark = new Person('mark', 24); console.log(typeOf(mark.instanceMethod)); // returns 'function' mark.instanceMethod(); // returns 'From an instance!' console.log(typeOf(mark.classMethod)); // returns 'null'，说明实例是不能调用静态方法的 console.log(typeOf(Person.classMethod)); // returns 'function' Person.classMethod(); // returns 'From the class itself!' console.log(typeOf(Person.instanceMethod)); // returns 'null'，同样类也不能直接调用为实例而创建的方法 Person.prototype.instanceMethod(); // 类只能通过这种方式调用原型上的方法 继承MooTools实现类的继承有两种模式：原型式继承和多亲继承，原型式继承由内建的Extends Mutator来实现，多亲继承由Implements Mutator或implement方法来实现。这里着重讲一下多亲继承。在JavaScript里，因为一个对象只能拥有一个原型对象，所以不允许子类继承多个超类，不过我们可以利用多个掺元类(minix class)或掺元对象对一个类进行扩充，这样类的实例就可以拥有mixin类(对象)中的方法、属性，所以这实际上实现了多继承的效果。通常mixin类(对象)包含一些通用的方法，大家可以看看MooTools里Class.Extras模块中三个mixin类的定义(Chain、Events、Options)：测试用例如下：首先我们先建立一个基类：123456 var Animal = new Class(&#123; initialize: function (age) &#123; this.age = age; &#125; &#125;); 使用Extends Mutator派生一个子类：123456789101112 var Cat = new Class(&#123; Extends: Animal, initialize: function (name, age) &#123; this.parent(age); // calls initalize method of Animal class this.name = name; &#125; &#125;); var cat = new Cat('Micia', 20); console.log(cat.name); // 'Micia' console.log(cat.age); // 20 利用Implements Mutator扩充一个类，首先建立一个mixin类：123456789101112131415161718192021222324 var Mixin = new Class(&#123; getName: function () &#123; return this.name; &#125;, setName: function (value) &#123; this.name = value &#125; &#125;); var Cat = new Class(&#123; Extends: Animal, Implements: Mixin, initialize: function (name, age) &#123; this.parent(age); // calls initalize method of Animal class this.name = name; &#125; &#125;); var cat = new Cat('Micia', 20); console.log(cat.name); // 'Micia' console.log(cat.age); // 20 cat.setName('Dog'); console.log(cat.getName()); // 'Dog' 还可以使用implement方法扩充一个类，示例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 // mixin对象存储一些通用方法，可以被不同的类implement var objMixin = (function () &#123; var counter = 0; return &#123; init: function () &#123; counter += 1; &#125;, getCounter: function () &#123; return counter; &#125;, getAge: function () &#123; return this.age; &#125;, setAge: function (value) &#123; this.age = value; &#125; &#125;; &#125;)(); var Cat = new Class(&#123; Extends: Animal, Implements: Mixin, initialize: function (name, age) &#123; this.parent(age); // calls initalize method of Animal class this.name = name; &#125; &#125;); Cat.implement(objMixin); var Dog = new Class(&#123; Extends: Animal, Implements: Mixin, initialize: function (name, age) &#123; this.parent(age); // calls initalize method of Animal class this.name = name; &#125; &#125;); Dog.implement(objMixin); var cat = new Cat('Micia', 20); console.log(cat.name); // 'Micia' console.log(cat.age); // 20 cat.setName('汤姆'); console.log(cat.getName()); // '汤姆' cat.setAge(12); console.log(cat.getAge()); // 12 // 对mixin对象的私有属性进行操作 cat.init(); console.log(cat.getCounter()); // 1 var dog = new Dog('小狗', 6); console.log(dog.name); // '小狗' console.log(dog.age); // 6 dog.setName('布鲁托'); console.log(dog.getName()); // '布鲁托' dog.setAge(8); console.log(cat.getAge()); // 8 // 对mixin对象的私有属性进行操作 dog.init(); console.log(dog.getCounter()); // 2 console.log(cat.getCounter()); /","tags":[]},{"title":"Mootools调研(5)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report5/","text":"3.4 调用方式Core 包含着mootools里面使用的公用方法:方法名: typeOf 返回对象的类别语法: typeOf(obj);参数:obj - (object) 要检查类别的对象。返回值:‘element’ - (string) 当对象是DOM Element时。‘elements’ - (string) 当对象是Element的集合时。‘textnode’ - (string) 当对象是文本节点时。‘whitespace’ - (string) 当对象是空白节点时，注意不是空字符串。 ‘arguments’ - (string) 当对象是函数的参数集合时。‘array’ - (string) 当对象是数组时。‘object’ - (string) 当对象是object时。‘string’ - (string) 当对象是string时。‘number’ - (string) 当对象是数字时。‘date’ - (string) 当对象是日期时。‘boolean’ - (string) 当对象是布尔型时。‘function’ - (string) 当对象是函数时。‘regexp’ - (string) 当对象是正则表达式时。‘class’ - (string) 当对象是一个类时 (用new Class 创建或者继承其他类的方式创建)。‘collection’ - (string) 当对象是html节点的集合时, 比如使用 childNodes 或者 getElementsByTagName得到的集合。‘window’ - (string) 当对象是window时。‘document’ - (string) 当对象是document时。‘domevent’ - (string) 当对象是一个事件时。‘null’ - (string) 当对象是 undefined, null, NaN 或者不是上面其他时。举例:123 var myString = 'hello'; typeOf(myString); // 返回\"string\" 注意:这个方法相当于MooTools1.2里面的$type，另外，undefined和null现在返回null，而不是false。 方法名: instanceOf 判定一个对象是不是特定类型的实例。语法: instanceOf(item, object)参数:item - (mixed) 对象实例。object - (mixed) 要比较的类型。返回值:(boolean) 对象是否是类型的实例。举例:12345678 var foo = []; instanceOf(foo, Array) // returns true instanceOf(foo, String) // returns false var myClass = new Class(); var bar = new myClass(); instanceOf(bar, myClass) // returns true 类型MooTools 扩展原生类型，比如string, array或者number使其更加有用。MooTools使用的（原生）类型：StringArrayNumberFunctionRegExpDateBooleanMooTools自定义的类型：ElementElementsEvent 类型的方法: implement这个方法在类型的prototype属性上面添加一个新的方法。语法: myType.implement(name, method);或者 myType.implement(methods);参数:name - (string) 方法名。method - (function) 方法。或者 methods - (object) 一个包含方法名和方法的键值对的对象。返回值: (object) 类型举例:123456789101112131415161718192021222324 Array.implement('limitTop', function(top)&#123; for (var i = 0, l = this.length; i &lt; l; i++)&#123; if (this[i] &gt; top) this[i] = top; &#125; return this; &#125;); [1, 2, 3, 4, 5, 6].limitTop(4); // returns [1, 2, 3, 4, 4, 4] 也可以传递一个对象 String.implement(&#123; repeat: function(times)&#123; var string = ''; while (times--) string += this; return string; &#125;, ftw: function()&#123; return this + ' FTW!'; &#125;&#125;); 'moo! '.repeat(3); // returns \"moo! moo! moo! \" 'MooTools'.ftw(); // returns \"MooTools FTW!\" ('MooTools'.ftw() + ' ').repeat(2); // returns \"MooTools FTW! MooTools FTW! \" 类型的方法: extend未类型添加一个或者多个方法。这些是静态的方法，比如把一个类型解析成另一种类型，或者其他实用功能。语法:myType.extend(name, method);或者 myType.extend(methods);参数:name - (string) 方法名。method - (function) 方法。或者 methods - (object) 一个包含方法名和方法的键值对的对象。返回值:(object) 类型。举例:12345678910 RegExp.extend('from', function(regexp, flags)&#123; return new RegExp(regexp, flags); &#125;); Number.extend('parseCurrency', function(currency)&#123; //接受一个字符串转换成数字以做一些其他运算。 &#125;); 通用方法许多类型的方法可以被用作通用方法。它们是javascript现有的方法、MooTools添加的方法，或者你自己扩展的方法。举例:123456789 var everyArgBiggerThanTwo = function()&#123; // 你可以用下面的代替 return Array.prototype.every.call(arguments, someFunction); // 用这个代替 return Array.every(arguments, someFunction); &#125;; 当一种类型使用另一种类型的方法的时候是非常有用的。像上面的例子，Arguments 类型并不是真正的数组，arguments.every(fn)是不能使用的，但是Array.every(arguments, fn)可以使用。语法:Type.methodName(thisArg[, arg1, arg2, …]);参数:thisArg - (mixed) 这是是要使用其他类型方法的对象。arg1, arg2, … - (mixed) 额外的参数会作为方法的参数传递。返回值:(mixed) 方法的返回值。 已过时方法方法名: $chk 该方法已被废弃，并且在MooTools 1.3以后没有代替的方法。如果确实需要的话，可以用下面的方法来实现：举例:123456 var $chk = function(obj)&#123; return !!(obj || obj === 0); &#125;; 方法名: $clear 该方法已被废弃，请用clearInterval或者clearTimeout代替。参见:MDC clearTimeout, MDC clearInterval方法名: $defined 该方法已被废弃。如果确实需要的话，可以用下面的方法来实现：举例:123456789101112 var $defined = function(obj)&#123; return (obj != undefined); &#125;; // 或者可以直接这样： if(obj != undefined)&#123; // do something&#125; 方法名: $arguments 该方法已被废弃，并且在MooTools 1.3以后没有代替的方法。如果确实需要的话，可以用下面的方法来实现：举例:12345678910 var $arguments = function(i)&#123; return function()&#123; return arguments[i]; &#125;; &#125;; 方法名: $empty 该方法已被废弃。使用Function.from代替。举例:12345 var myFunc = Function.from(); // 或者更好的方式： var myFunc = function()&#123;&#125;; 方法名: $lambda 该方法已被废弃。使用Function.from代替。举例:12 myLink.addEvent('click', Function.from(false)); // 取消一个链接的点击事件。 方法名: $extend 该方法已被废弃。请用Object.append代替。 方法名: $merge 该方法已被废弃。请用Object.merge代替。 方法名: $each 该方法已被废弃。请用Array.each或者Object.each代替 方法名: $pick 该方法已被废弃。请用Array.pick代替。 方法名: $random 该方法已被废弃。请用Number.random代替。 方法名: $splat 该方法已被废弃。请用Array.from代替。$splat 不能转换‘类数组’对象，比如节点集合、参数集合，Array.from可以。 方法名: $time 该方法已被废弃。请用Date.now() 代替。语法:var time = Date.now();返回值:(number) - 当时时间戳。 方法名: $try 该方法已被废弃。请用Function.attempt代替。 方法名: $type 该方法已被废弃。请用typeOf代替。","tags":[]},{"title":"Mootools调研(1)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report1/","text":"1 概述1.1 框架名称MooTools是个精简、模块化同时也对象导向的JavaScript框架，设计给中等与进阶的JavaScript开发员使用。透过其优美、详细而条理分明的API，可以让您写出强大、富有弹性且跨浏览器的程序。——MooTools官网 1.2 背景MooTools是Valerio Proietti首先提出，他以Prototype和Dean Edward的BASE2为灵感，并在2006年9月发布。MooTools起源于Moo.fx —— 一个流行的插件，由Proietti在2005年10月为Prototype开发，现在仍在维护和使用中。针对原型扩展——提供了许多JavaScript的原生字符串，数组，和拥有附加方法的函数对象，当时的Proietti想要一个框架，从而进一步扩展原生Element对象，以提供更强的文档对象模型（DOM）控制。 1.3 设计思想MooTools的设计思想是面向对象的设计思想。MooTools包含很多组件，官方网站MooTools支持你下提取自己需要的独立代码而不需要全部下载， 同时可以选择压缩的级别。这些组件分别是： Core：常用函数集合，其它组件必须的；Class：MoolTools类的实例化的基础库；Natives：原始类的扩展；Element：包含一些对html element及其扩展；Fx：一个动态元素高级效果的API；Requests：为开发者提供xhttpRequest cookie json html特定检索工具；Window：提供一个获取client信息的跨浏览器接口。 1.4 其他MooTools 1.4.5是目前最新版本，文档完整，有活跃的社区，还有一个IRC。MooTools官方维护了一个blog，供开发者讨论。MooTools从Prototype.js中汲取了许多有益的设计理念，语法也和其极其类似。但它提供的功能要比Prototype.js多，整体设计也比Prototype.js要相对完善，功能更强大。MooTools在复杂项目有着很大的优势，下面介绍MooTools在大型项目上的优势点： 更多的对象方法扩展：虽然说，MooTools框架直接在Array, Function对象上做方法扩展有可能会造成语后来JavaScript规范出现重复或冲突的情况，但是，这些对象方法的扩展对我们的开发节约了很多的功夫。MooTools框架在各类JavaScript类型对象上做了新方法的扩展，以便我们可以更轻松更简单地应付各类复杂应用和众多数据处理。这显然与jQuery重在DOM的设计理念不同了。据处理利器之Hash概念：Hash，俗称哈希，是jQuery中没有而MooTools中有且很赞的一个玩意。Hash是一个重新实现的Object({}), 被专门用于数据的存取，和原来的Object({})的区别是： 它不会在进行存值，取值或迭代的时候处理对象的prototype中的内容。在MooTools中，Hash对象和Array对象(json基本构成啦)联合使用，再庞杂的数据，都能轻松应付。面向对象的设计思想：MooTools是一款面向对象的设计思想框架。讲求继承，模块化与重用性。虽然，MooTools这种强制面向对象风格的设计有些淡化了JavaScript语言本身的一些优美特性。但是，当项目庞大，JavaScript代码量巨大的时候，这种面向对象的设计理念还是相当受用的。项目越大，偶们所节省的代码量就越多。Cookie的读写：MooTools框架自带Cookie读写的方法，支持指定域和路径。而jQuery框架中要想实现Cookie的读写，需要借助于专门的cookie插件。swf文件的载入：MooTools框架自带Swiff类，可以实现页面上flash文件的载入，而不需要求助google的swfobject方法。更全面的动画效果：MooTools框架的动画效果实际上要比jQuery的强些，但是，不足在于其使用的API要比jQuery逊色。说MooTools框架动画要比jQuery强，其中之一就是MooTools动画内置了贝塞尔运动曲线关键字。如：’linear’, ‘quad:in’, ‘back:in’, ‘bounce:out’, ‘elastic:out’, ‘sine:in:out’等等（下图为Fx.Transitions方法之expo），而jQuery实现类似缓动效果，还需要借助ease插件。form表单序列化提交：MooTools自身携带HTML表单控件元素数据序列化方法，表单元素自身携带了ajax提交方法，而jQuery框架要实现类似的功能，还需要专门的表单序列化插件。 MooTools虽然也能用在中小项目上，但是，其潜力的发挥要在大型、需要编写大量JavaScript的应用的网站项目上。这就是MooTools的优势。MooTools的劣势同样也是由于设计思想的不同引起的： 修改了低层的一些类：如Array, String等 在DOM和CSS Selector上不如jQuery强大 JS框架中侵入性最大。","tags":[]},{"title":"Mootools调研(6)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report6/","text":"3.5 组件的组织结构MooTools框架主要有mootools-core以及mootools-more这两大部分组成。mootools-core是MooTools框架的核心模块，mootools-more是针对mootools-core的功能扩展部分，可根据需求动态引入。无论是mootools-core还是mootools-more都可针对具体需求，选择需要的模块，根据模块以来关系组装出最小的js包使得尽量小的框架代码实现所需功能。 如下图所示，是详细的MooTools框架体系结构： 3.6 其他正因为mootools是基于OO的思想，所以，在mootools自身提供的功能中，充分使用了OO的理念–继承和实现.mootools中提供一组基础功能类：Chain,Events,Options,Group，然后我们可以通过implement他们来在我们的类中实现它们所提供的功能。mootools自己提供的Ajax, XHR和Fx.Base类就实现了这些基础功能类。 类：Chain作用：这里Chain类把function组织成一个链式结构。它提供了三个方法： chain - 添加一个函数到链中callChain - 执行链中第一个函数，然后删除(原来链中第二个函数将变为新的链首)clearChain - 清除链中所有函数 123456789101112131415161718 var c = new Chain().chain(function()&#123; alert('Func A!'); &#125;).chain(function()&#123; alert('Func B!'); &#125;).chain(function()&#123; alert('Func C!'); &#125;); c.callChain(); //\"Func A!\" c.callChain(); //\"Func B!\" c.callChain(); //\"Func C!\" ####类：Events作用：通俗的来讲，它其实像是一个事件管理器(各人觉得大多数情况下应该是自定义事件)。别的类可以实现它来进行自己的事件管理。它同样提供了三个方法： addEvent - 向管理器中添加指定事件的监听器fireEvent - 触发执行指定事件下的所有监听器方法removeEvent 12345678910111213 var evts = new Events(); var fa = function(e)&#123; alert('aaaaaaa'); &#125;; var fb = function(e)&#123; alert('bbbbbbb'); &#125;; evts.addEvent('onMyEvent', fa).addEvent('myEvent', fb); evts.fireEvent('onMyEvent'); //先alert出\"aaaaaaa\",然后alert出\"bbbbbbb\" evts.removeEvent('onMyEvent',fa); evts.fireEvent('onMyEvent'); //alert 出\"bbbbbbb\" 类：Options作用：为实现该类的类提供一个可选参数管理器。它提供了一个方法： setOptions - 设置类的this.options,该方法的第一个参数是要给出的默认参数列表，第二个参数是可提供用户输入的参数列表。如果实现同时实现Options类和Events类，则参数列表中有以on开头(/^on[A-Z]/)的参数名，则自动会把这些参数加入到Events提供的事件管理器中。 123456789101112131415161718192021 var MyClass = new Class(&#123; initialize: function(options)&#123; this.setOptions(&#123; width: '100px', height: '200px', onMyEvent: Class.empty &#125;,options); &#125; &#125;); MyClass.implement(new Options()); //自定义类实现Options MyClass.implement(new Events()); //自定义类实现Events //实例化MyClass var c = new MyClass(&#123; deep: '100px', onMyEvent: function()&#123;alert('option[deep]&gt;:' + this.options['deep']);&#125; &#125;); c.fireEvent('onMyEvent'); //alert出\"option[deep]:100px\" 类：Group作用：把元素分组，然后可以为这些组进行添加事件监听器，这些“组监听器”的触发时机是这样的：当组里面的所有元素都触发过指定的事件后，”组监听器”就开始执行。比如有3个按钮A,B,C组成一个Group,然后为这个Group添加一个click事件的监听器方法，则，当你分别去按这3个按钮，不分次序，不分按的次数（比如A按了1次，B按了2次,然后再按C）,当按最后一个按钮时候(比如已经按过了A和B，现在按下C)，那个“组监听器”就被执行了。1234 &lt;a href=\"#\" id=\"link1\" &gt;AAA&lt;/a&gt;;&lt;a href=\"#\" id=\"link2\" &gt;;BBB &lt;/a&gt;;&lt;a href=\"#\" id=\"link3\" &gt;;CCC &lt;/a&gt;; 1234567891011121314 $('link1').addEvent('click',function()&#123;alert('AAA');&#125;); $('link2').addEvent('click',function()&#123;alert('BBB');&#125;); $('link3').addEvent('click',function()&#123;alert('CCC');&#125;); var g = new Group($('link1'),$('link2'),$('link3')); g.addEvent('click', function()&#123; alert('group event'); &#125;); //当你按照类似如下规律点击链接： //先点击link1：alert出\"AAA\" //再点击link2：alert出\"BBB\" //最后点击link3：先alert出\"group event\"，再alert出\"CCC\" 一般情况下，Chain,Events和Options都不会单独使用，都会被别的类implement，来为这些类提供功能增强。","tags":[]},{"title":"Mootools调研(2)","date":"2014-01-26T16:00:00.000Z","path":"2014/01/27/MooTools-search-report2/","text":"2 规范2.1 组件命名规范MooTools的方法命名属于传统对称命名的方式(prop为property属性缩写)，且语义明显，这种设计可以有效避免与原生dom方法的冲突。在core中为全局window对象定义MooTools对象，并且全局定义了其他常用组件的集合。1234567 (function()&#123; this.MooTools = &#123; version: '1.4.5', build: '74e34796f5f76640cdb98853004650aea1499d69' &#125;;&#125;) MooTools没有在核心代码中提供命名空间定义方法，在官方网站的Forge找到：Namespace.class.js，可选择引用。该方法引用 core/Class.Extras和core/Request。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161 /*---Script: Namespace.class.jsAuthor: Eric Clemmons &lt;eric@smarterspam.com&gt;Description: Allows for slightly new Class instantiations for name.spacingRequires:- core/Class.Extras- core/RequestProvides: [Namespace]License: MIT-style*/var Namespace = new Class(&#123; Implements: Options, options: &#123; root: window, // You can set the base for your namespace. Defaults to `window` delimiter: \".\" // Delimiter for namespacing &#125;, // Accepts the namespace path \"my.namespace.path\" &amp; the class options for instantiation initialize: function(namespace, options) &#123; if (options.namespace) &#123; this.setOptions(options.namespace); &#125;; // Parse options for strings where classes should exist options = this.parseOptions(options); // Return the instantiated class return this.getClass(namespace, options); &#125;, parseOptions: function(options) &#123; // Replace `Extends: \"myClass\"` with `Extends: myClass` instantiation var params = [\"Implements\", \"Extends\", \"Requires\"]; // Iterate through each type of dependency (i.e. \"Extends\") params.each(function(param) &#123; var resources = $splat(options[param]); resources.each(function(resource, i) &#123; // If the dependency isn't a class yet, try to load the class if ($type(resource) === \"string\") &#123; // Get existing class or load it via SJAX var resource = this.load(resource); // If class finally exists, assign it to it's key (for Requires) // or to the param itself (for Extends) if ($type(resource) === \"class\") &#123; if ($type(options[param]) === \"array\") &#123; options[param][i] = resource; &#125; else &#123; options[param] = resource; &#125; &#125; else &#123; if (param !== \"Requires\") &#123; throw new Error(param + \" class \\\"\" + resource + \"\\\" does not exist or could not be loaded.\"); &#125; &#125; &#125; &#125;, this); &#125;, this); return options; &#125;, // Traverses down the namespace path and returns the (newly instantiated if not existing) class getClass: function(namespace, options) &#123; var root = this.options.root; // Iterate through each section of the namespace namespace.split(this.options.delimiter).each(function(name, i, names) &#123; // Up until the last leaf, create an object if undefined if (i &lt; names.length - 1) &#123; if (!root[name]) &#123; root[name] = &#123;&#125;; &#125; &#125; else &#123; // If the last leaf doesn't exist &amp; we're looking to instantiate, instantiate the class if (!root[name] &amp;&amp; options) &#123; return root[name] = new Class(options); &#125; &#125;; root = root[name]; &#125;); // Return the requested namespaced class return root; &#125;, load: function(namespace) &#123; (new Request(&#123; url: Namespace.getBasePath(namespace) + \".js\", method: 'GET', async: false, evalResponse: true &#125;)).send(); return this.getClass(namespace); &#125; &#125;);Namespace.paths = &#123; _base: \".\"&#125;;Namespace.setBasePath = function(namespace, path) &#123; if (!path) &#123; var path = namespace; var namespace = \"_base\"; &#125; Namespace.paths[namespace] = path;&#125;;Namespace.getBasePath = function(namespace) &#123; // Start with the base path var path = Namespace.paths._base; // Iterate through each specified namespace path (\"Moo.Core\" =&gt; \"js/Moo/Core/Source\") for (var stub in Namespace.paths) &#123; if (stub === namespace.substring(0, stub.length)) &#123; path += \"/\" + Namespace.paths[stub]; // Remove stub from namespace, as we've already pathed it namespace = namespace.substring(stub.length + 1); break; &#125; &#125; return path + \"/\" + namespace.replace(/\\./g, \"/\");&#125;;Namespace.require = function(namespaces) &#123; $splat(namespaces).each(function(namespace) &#123; new Namespace(namespace, &#123; Requires: namespace &#125;); &#125;);&#125;;// Initialize base path based on Namespace script &amp; document URL;(function() &#123; // Get the last script loaded (should be this script) var script = $$('script').getLast(); // Trim off the script name var jsUrl = script.src.substring(0, script.src.lastIndexOf(\"/\")); // Trim off the page name as well var baseUrl = document.URL.substring(0, document.URL.lastIndexOf(\"/\") + 1); // Subtract page path from script path to get script subfolder var path = jsUrl.replace(baseUrl, ''); Namespace.setBasePath(path);&#125;)(); 2.2 模块化规范支持了AMD规范，自己作为一个模块而存在。","tags":[]},{"title":"HTML5 Canvas浅析(2)","date":"2014-01-25T16:00:00.000Z","path":"2014/01/26/HTML5Canvas-2/","text":"2. Canvas开发浅尝2.1. 渲染上下文canvas 初始化是空白的，要在上面用脚本画图首先需要其渲染上下文（rendering context），它可以通过 canvas 元素对象的getContext方法来获取，同时得到的还有一些画图用的函数。getContext()接受一个用于描述其类型的值作为参数。现在“2d”是唯一支持的值。 2.2. APIcanvas元素本身并没有绘制能力（它仅仅是图形的容器），您必须使用脚本来完成实际的绘图任务。getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。 2.2.1. 颜色、样式和阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 方法 描述 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 2.2.2. 线条样式 属性 描述 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 2.2.3. 矩形 方法 描述 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 2.2.4. 路径 方法 描述 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 2.2.5. 转换 方法 描述 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 2.2.6. 文本 属性 描述 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 方法 描述 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 2.2.7. 图像绘制 方法 描述 drawImage() 向画布上绘制图像、画布或视频 2.2.8. 像素操作 属性 描述 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 方法 描述 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 2.2.9. 合成 属性 描述 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 2.2.10. 其他 方法 描述 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 createEvent() getContext() toDataURL()","tags":[]},{"title":"js有限状态机（Finite State Machine）浅析","date":"2013-12-19T16:00:00.000Z","path":"2013/12/20/javascript-state-machine/","text":"项目中正好要用到有限状态机js微框架（javascript-state-machine）。所以，下面对有限状态机的概念和这个框架做一些调研和分析。 有限状态机（FSM）有限状态机（finite-state machine, FSM），又称有限状态自动机，状态机。是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。可参考wiki-有限状态机 状态机有三个特征： 状态总数（state）是有限的。任一时刻，只处在一种状态之中。某种条件下，会从一种状态转变（transition）到另一种状态。 状态机有几个重要的概念：状态、条件和动作。 状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。状态可以无限细分，也可以大致归类，需要根据实际应用进行划分。例如下拉菜单，可以分为两个状态：隐藏列表和显示列表。条件触发状态变化。满足了特定的条件，动作才会发生。例如，鼠标mouseover菜单和mouseout菜单，是触发状态切换的条件。动作是在给定时刻要进行的活动的描述。在上面的例子里，动作是指将隐藏列表显示，或者将显示列表隐藏的行为。这个和状态不同，状态其实是我们自己的定义，为了方便理解，赋予他一定的意义。","tags":[]},{"title":"HTML5 Canvas浅析(1)","date":"2013-12-13T16:00:00.000Z","path":"2013/12/14/HTML5Canvas-1/","text":"HTML5引进了很多新特性，其中最受人关注的就有Canvas。Canvas元素以及JS引擎中新增的一些特性，让前端开发者不必借助第三方插件，即可开发出精细且具有交互性的2D网页。本文就向大家介绍一下Canvas元素。 1. Canvas背景介绍1.1. Canvas由来Canvas的概念最初是由苹果公司提出的，用于在Mac OS X WebKit中创建控制板部件(dashboard widget)。在Canvas出现之前，开发人员若要在浏览器中使用绘图API，只能使用Adobe的Flash和SVG(Scalable Vector Graphics，可伸缩矢量图形)插件，或者只有IE才支持的VML(Vector Markup Language，矢量标记语言)，以及其他一些稀奇古怪的JS技巧。Canvas提供的绘图功能，对浏览器端来说非常有用，因此被纳入了HTML5规范。苹果公司还曾暗示过，可能会为Canvas规范申请知识产权。不过，最终还是按照W3C的免版税专利权许可条款公开了其专利。 1.2. Canvas是什么Canvas元素只是一块无色透明的矩形区域。和img元素不同的是它不含src和alt属性。canvas只有两个属性：width 和 height。这两个属性可选，并且都可以用 DOM 属性或者 CSS 规则来设置。如果不指定width 和 height，默认的是宽300像素，高150像素。注：id属性不是canvas专享的，就像标准的HTML标签一样，任何一个HTML元素都可以指定其id值。同大多数HTML元素一样，canvas元素可以通过应用CSS来设置样式，而且一些CSS属性还可以被canvas内的元素继承。比如字体样式，在canvas内添加的文字，其样式默认同canvas元素本身是一样的。此外，还可以为canvas内的元素设置CSS属性。跟在任何HTML和CSS文档中使用的语法一样。在页面中加入canvas元素后，我们便可以通过JS来控制它。可以在其中添加图片、线条以及文字，也可以绘图，甚至还可以加入高级动画。Canvas API支持大多数主流操作系统和框架支持的二维绘制操作。并且是参照既有系统设计的。 1.3. Canvas坐标在Canvas上作图，需要了解画布的坐标规则：canvas元素的左上角为原点(0,0)，向右为x轴正方向，向下为y轴正方向。 1.4. Canvas支持浏览器因为canvas相对较新，有些浏览器并没实现，所以我们需要为那些不支持canvas的浏览器提供替用显示内容。我们只需要直接在canvas元素内插入替用内容即可。不支持canvas的浏览器会忽略canvas元素而直接渲染替用内容，而支持的浏览器则会正常地渲染canvas。 注：结束标签(&lt;/canvas&gt;)是必须的。safari之前据说能忽略结束标签，现在测试不行除了显示替用内容，还可以通过脚本的方式来检查浏览器是否支持Canvas。方法很简单，判断 getContext 是否存在即可。 1.5. canvas demos现在有很多有意思的canvas应用，如下：canvas color cycling HTML5 Video Destruction Zen Photon Garden Tear-able Cloth","tags":[]},{"title":"sublime text2 快捷键","date":"2013-12-12T16:00:00.000Z","path":"2013/12/13/sublimeText2/","text":"总结操作快捷键： 自动完成的快捷键是Tab， 加上zencoding插件后，更是如虎添翼 按住ctrl点击鼠标，会出现多个闪烁的光标，这时可同时修改多处==== 或者按住鼠标中键拖拽 ctrl+/、ctrl+shift+/分别未行注释和块注释，再按一下就能去掉注释，ST2能够自动识别是html、css还是js文件，给出不同类型的注释。 右键功能： show unsaved changes，显示未保存的修改，红色减号表示删去的内容，绿色加号表示新增的内容 折叠功能， mouseover到侧边栏就会显示折叠三角号 主要快捷键列表：Ctrl+L：选择整行（按住-继续选择下行）Ctrl+KK：从光标处删除至行尾Ctrl+Shift+K：删除整行Ctrl+Shift+D：复制光标所在整行，插入在该行之前Ctrl+J：合并行（已选择需要合并的多行时）Ctrl+KU：改为大写Ctrl+KL：改为小写Ctrl+D：选词 （按住-继续选择下个相同的字符串）Ctrl+M：光标移动至括号内开始或结束的位置Ctrl+Shift+M：选择括号内的内容（按住-继续选择父括号）Ctrl+/：注释整行（如已选择内容，同“Ctrl+Shift+/”效果）Ctrl+Shift+/：注释已选择内容Ctrl+Z：撤销Ctrl+Y：恢复撤销Ctrl+M：光标跳至对应的括号Alt+.：闭合当前标签Ctrl+Shift+A：选择光标位置父标签对儿Ctrl+Shift+[：折叠代码Ctrl+Shift+]：展开代码Ctrl+KT：折叠属性Ctrl+K0：展开所有Ctrl+U：软撤销Ctrl+T：词互换Tab：缩进 自动完成Shift+Tab：去除缩进Ctrl+Shift+↑：与上行互换Ctrl+Shift+↓：与下行互换Ctrl+K Backspace：从光标处删除至行首Ctrl+Enter：光标后插入行Ctrl+Shift+Enter：光标前插入行Ctrl+F2：设置书签F2：下一个书签Shift+F2：上一个书签","tags":[]}]